# file: roles/k8s_master/tasks/main.yaml

- name: Create the /var/tmp/ansible directory
  file:
    path: /var/tmp/ansible
    owner: root
    group: root
    mode: 0700    
    state: directory


#   ___  ____       ____  ____  _____ ____ ___ _____ ___ ____ 
#  / _ \/ ___|     / ___||  _ \| ____/ ___|_ _|  ___|_ _/ ___|
# | | | \___ \ ____\___ \| |_) |  _|| |    | || |_   | | |    
# | |_| |___) |_____|__) |  __/| |__| |___ | ||  _|  | | |___ 
#  \___/|____/     |____/|_|   |_____\____|___|_|   |___\____|
#                                                             
- include_tasks: ubuntu.yaml
  when: ansible_distribution == "Ubuntu"
  tags:
    - unbound

- include_tasks: centos.yaml
  when: ansible_distribution == "CentOS"
  tags:
    - unbound


#  _  _____ ____       _    _     _       __  __    _    ____ _____ _____ ____  ____  
# | |/ ( _ ) ___|     / \  | |   | |     |  \/  |  / \  / ___|_   _| ____|  _ \/ ___| 
# | ' // _ \___ \    / _ \ | |   | |     | |\/| | / _ \ \___ \ | | |  _| | |_) \___ \ 
# | . \ (_) |__) |  / ___ \| |___| |___  | |  | |/ ___ \ ___) || | | |___|  _ < ___) |
# |_|\_\___/____/  /_/   \_\_____|_____| |_|  |_/_/   \_\____/ |_| |_____|_| \_\____/ 
#                                                                                     
- name: Create the configuration directories for the Kubernetes API server and scheduler
  block:
  - name: Create the /etc/kubernetes/apiserver directory
    file:
      path: /etc/kubernetes/apiserver
      state: directory
  
  - name: Create the /etc/kubernetes/scheduler directory
    file:
      path: /etc/kubernetes/scheduler
      state: directory

- name: Copying the standard keys and certificates for the "{{ k8s_cluster_name }}" Kubernetes cluster
  block:
  - name: Create the /etc/kubernetes/pki/etcd directory
    file:
      path: /etc/kubernetes/pki/etcd
      state: directory
  
  - name: Copy the Kubernetes intermediate CA private key to the /etc/kubernetes/pki directory
    copy:
      src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-ca.key
      dest: /etc/kubernetes/pki/ca.key

  - name: Copy the Kubernetes intermediate CA certificate to the /etc/kubernetes/pki directory
    copy:
      src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-ca.crt
      dest: /etc/kubernetes/pki/ca.crt


#  _  _____ ____    _____ ___ ____  ____ _____   __  __    _    ____ _____ _____ ____  
# | |/ ( _ ) ___|  |  ___|_ _|  _ \/ ___|_   _| |  \/  |  / \  / ___|_   _| ____|  _ \ 
# | ' // _ \___ \  | |_   | || |_) \___ \ | |   | |\/| | / _ \ \___ \ | | |  _| | |_) |
# | . \ (_) |__) | |  _|  | ||  _ < ___) || |   | |  | |/ ___ \ ___) || | | |___|  _ < 
# |_|\_\___/____/  |_|   |___|_| \_\____/ |_|   |_|  |_/_/   \_\____/ |_| |_____|_| \_\
#                                                                                      
- name: Initialize the first master node in the Kubernetes cluster
  block:      
  - name: Check whether the kubelet service has been configured
    stat:
      path: /var/lib/kubelet/config.yaml
    register: kubelet_config_stat_result

  - name: Initializing the first master node in the Kubernetes cluster
    block:
    - name: Copying the keys and certificates for the stacked etcd topology
      block:
      - name: Copy the Kubernetes intermediate CA private key to the /etc/kubernetes/pki/etcd directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-etcd-ca.key
          dest: /etc/kubernetes/pki/etcd/ca.key

      - name: Copy the Kubernetes intermediate CA certificate to the /etc/kubernetes/pki/etcd directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-etcd-ca.crt
          dest: /etc/kubernetes/pki/etcd/ca.crt

      when: k8s_etcd_topology == "stacked"

    - name: Copying the keys and certificates for the external etcd topology
      block:
      - name: Copy the etcd-ca.crt certificate to the /etc/kubernetes/pki/etcd directory
        copy:
          src: pki/{{ k8s_cluster_name }}/etcd-ca.crt
          dest: /etc/kubernetes/pki/etcd/ca.crt

      - name: Copy the {{ inventory_hostname_short }}-etcd-client.key private key to the /etc/kubernetes/pki/etcd directory
        copy:
          src: pki/{{ k8s_cluster_name }}/{{ inventory_hostname_short }}-etcd-client.key
          dest: /etc/kubernetes/pki/etcd/{{ inventory_hostname_short }}-etcd-client.key

      - name: Copy the {{ inventory_hostname_short }}-etcd-client.crt certificate to the /etc/kubernetes/pki/etcd directory
        copy:
          src: pki/{{ k8s_cluster_name }}/{{ inventory_hostname_short }}-etcd-client.crt
          dest: /etc/kubernetes/pki/etcd/{{ inventory_hostname_short }}-etcd-client.crt

      when: k8s_etcd_topology == "external"

    - command:
        cmd: hostname -i
      register: hostname_i_result

    - set_fact:
        k8s_apiserver_advertise_address: "{{ hostname_i_result.stdout_lines[0] }}"

    - name: Create the Kubernetes API server encryption configuration
      block:
      - name: Generate the Kubernetes API server encryption key
        shell:
          cmd: head -c 32 /dev/urandom | base64
        register: generate_kube_apiserver_encryption_key_result
        
      - set_fact:
          kube_apiserver_encryption_key: "{{ generate_kube_apiserver_encryption_key_result.stdout }}"
        
      - template:
          src: k8s-apiserver-encryption.yaml.j2
          dest: /etc/kubernetes/apiserver/encryption.yaml
        
      - name: Set the permissions for the /etc/kubernetes/apiserver/encryption.yaml file
        file:
          path: /etc/kubernetes/apiserver/encryption.yaml
          owner: root
          group: root
          mode: 0600
          state: file
        
    - name: Create the Kubernetes scheduler configuration
      block:
      - name: Create the scheduler-config.yaml configuration file under the /etc/kubernetes/scheduler directory
        template:
          src: scheduler-config.yaml.j2
          dest: /etc/kubernetes/scheduler/scheduler-config.yaml

      - name: Create the scheduler-policy.cfg configuration file under the /etc/kubernetes/scheduler directory
        template:
          src: scheduler-policy.cfg.j2
          dest: /etc/kubernetes/scheduler/scheduler-policy.cfg
              
    - name: Create the Kubernetes cluster configuration
      template:
        src: k8s-config.yaml.j2
        dest: /var/tmp/ansible/k8s-config.yaml              

    - name: Initialize the Kubernetes cluster
      shell:
        cmd: /usr/bin/kubeadm init --config /var/tmp/ansible/k8s-config.yaml

    - name: Copy the Kubernetes configuration to the root user
      block:
      - name: Create the /root/.kube directory
        file:
          path: /root/.kube
          owner: root
          group: root
          mode: 0700
          state: directory

      - name: Copy the /etc/kubernetes/admin.conf file to the /root/.kube directory
        command:
          cmd: cp /etc/kubernetes/admin.conf /root/.kube/config

      - name: Set the permissions for the /root/.kube/config file
        file:
          path: /root/.kube/config
          owner: root
          group: root
          mode: 0600
          state: file

    - name: Copy the Kubernetes configuration to the k8s-admin user
      block:
      - name: Create the /home/k8s-admin/.kube directory
        file:
          path: /home/k8s-admin/.kube
          owner: k8s-admin
          group: k8s-admin
          mode: 0750
          state: directory

      - name: Copy the /etc/kubernetes/admin.conf file to the /home/k8s-admin/.kube directory
        command:
          cmd: cp /etc/kubernetes/admin.conf /home/k8s-admin/.kube/config

      - name: Set the permissions for the /home/k8s-admin/.kube/config file
        file:
          path: /home/k8s-admin/.kube/config
          owner: k8s-admin
          group: k8s-admin
          mode: 0640
          state: file
              
    - name: Setup the kubeshell script
      block:
      - name: Create the kubeshell script
        template:
          src: kubeshell.j2
          dest: /usr/bin/kubeshell
          
      - name: Set the permissions for the kubeshell script
        file:
          path: /usr/bin/kubeshell
          owner: root
          group: root
          mode: 0750
          state: file          

    - name: Allows pods to scheduled on the master if there are no worker nodes
      command:
        cmd: /usr/bin/kubectl taint node {{ inventory_hostname_short }} node-role.kubernetes.io/master:NoSchedule-
      when: ("k8s_worker" not in groups.keys())

    - name: Create the Prometheus service account
      block:
      - template:
          src: prometheus-service-account.yaml.j2
          dest: /var/tmp/ansible/prometheus-service-account.yaml

      - shell:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/prometheus-service-account.yaml

    - name: Deploy the kube-state-metrics service if there are no worker nodes
      block:
      - template:
          src: kube-state-metrics.yaml.j2
          dest: /var/tmp/ansible/kube-state-metrics.yaml

      - shell:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/kube-state-metrics.yaml

    when: kubelet_config_stat_result.stat.exists == False

  - name: Check whether a CNI provider has been configured
    stat:
      path: /etc/cni
    register: etc_cni_stat_result

  - name: Configure the Weave CNI provider
    block:
    - name: Initialize the Weave CNI provider
      shell:
        cmd: /usr/bin/kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(/usr/bin/kubectl version | base64 | tr -d '\n')&env.IPALLOC_RANGE={{k8s_pod_subnet}}"

    - name: Download the Weave script
      get_url:
        url: https://git.io/weave
        dest: /usr/bin/weave
      register: download_weave_script_result
      until: download_weave_script_result is succeeded
      retries: 3
      delay: 10

    - name: Set the permissions for the /usr/bin/weave file
      file:
        path: /usr/bin/weave
        owner: root
        group: root
        mode: 0770
        state: file
        
    - name: Sleep for 15 seconds to allow the Weave CNI provider to initialize
      wait_for:
        timeout: 15
        
    when: ((etc_cni_stat_result.stat.exists == False) and (k8s_cni_provider == 'weave'))

  - name: Wait for Kubernetes node initialization to complete
    command:
      cmd: /usr/bin/kubectl wait --namespace=kube-system --for=condition=Ready pods --all --timeout=600s

  when: groups['k8s_master'][0] == inventory_hostname


#  _  _____ ____       _    ____  ____ ___ _____ ___ ___  _   _    _    _       __  __    _    ____ _____ _____ ____  
# | |/ ( _ ) ___|     / \  |  _ \|  _ \_ _|_   _|_ _/ _ \| \ | |  / \  | |     |  \/  |  / \  / ___|_   _| ____|  _ \ 
# | ' // _ \___ \    / _ \ | | | | | | | |  | |  | | | | |  \| | / _ \ | |     | |\/| | / _ \ \___ \ | | |  _| | |_) |
# | . \ (_) |__) |  / ___ \| |_| | |_| | |  | |  | | |_| | |\  |/ ___ \| |___  | |  | |/ ___ \ ___) || | | |___|  _ < 
# |_|\_\___/____/  /_/   \_\____/|____/___| |_| |___\___/|_| \_/_/   \_\_____| |_|  |_/_/   \_\____/ |_| |_____|_| \_\
#                                                                                                                     
- name: Initialize an additional master node in the Kubernetes cluster
  block:
  - name: Check whether the kubelet service has been configured
    stat:
      path: /var/lib/kubelet/config.yaml
    register: kubelet_config_stat_result
      
  - name: Initializing the additional master node in the Kubernetes cluster
    block:
    - name: Fetch the /etc/kubernetes/scheduler/scheduler-config.yaml file from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/scheduler/scheduler-config.yaml
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"
    
    - name: Copy the /etc/kubernetes/scheduler/scheduler-config.yaml to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/scheduler/scheduler-config.yaml
        dest: /etc/kubernetes/scheduler/scheduler-config.yaml
    
    - name: Fetch the /etc/kubernetes/scheduler/scheduler-policy.cfg file from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/scheduler/scheduler-policy.cfg
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"
    
    - name: Copy the /etc/kubernetes/scheduler/scheduler-policy.cfg to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/scheduler/scheduler-policy.cfg
        dest: /etc/kubernetes/scheduler/scheduler-policy.cfg
      
    - name: Fetch the /etc/kubernetes/apiserver/encryption.yaml file from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/apiserver/encryption.yaml
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"
    
    - name: Copy the /etc/kubernetes/apiserver/encryption.yaml to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/apiserver/encryption.yaml
        dest: /etc/kubernetes/apiserver/encryption.yaml
        
    - name: Set the permissions for the /etc/kubernetes/apiserver/encryption.yaml file
      file:
        path: /etc/kubernetes/apiserver/encryption.yaml
        owner: root
        group: root
        mode: 0600
        state: file
          
    - name: Remove the local copy of the encryption.yaml file
      become: no
      local_action: file path=fetched_files/{{ inventory_hostname }}/etc/kubernetes/apiserver/encryption.yaml state=absent     
    
    - name: Fetch the /etc/kubernetes/pki/sa.key from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/sa.key
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/sa.key to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/sa.key
        dest: /etc/kubernetes/pki/sa.key

    - name: Fetch the /etc/kubernetes/pki/sa.pub from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/sa.pub
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/sa.pub to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/sa.pub
        dest: /etc/kubernetes/pki/sa.pub

    - name: Fetch the /etc/kubernetes/pki/front-proxy-ca.key from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/front-proxy-ca.key
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/front-proxy-ca.key to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/front-proxy-ca.key
        dest: /etc/kubernetes/pki/front-proxy-ca.key

    - name: Fetch the /etc/kubernetes/pki/front-proxy-ca.crt from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/front-proxy-ca.crt
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/front-proxy-ca.crt to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/front-proxy-ca.crt
        dest: /etc/kubernetes/pki/front-proxy-ca.crt

    - name: Fetch the /etc/kubernetes/pki/etcd/ca.key from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/etcd/ca.key
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/etcd/ca.key to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/etcd/ca.key
        dest: /etc/kubernetes/pki/etcd/ca.key

    - name: Fetch the /etc/kubernetes/pki/etcd/ca.crt from the first master node in the Kubernetes cluster
      fetch:
        src: /etc/kubernetes/pki/etcd/ca.crt
        dest: fetched_files
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Copy the /etc/kubernetes/pki/etcd/ca.crt to the additional master
      copy:
        src: fetched_files/{{ inventory_hostname }}/etc/kubernetes/pki/etcd/ca.crt
        dest: /etc/kubernetes/pki/etcd/ca.crt

    - command:
        cmd: hostname -i
      register: hostname_i_result

    - set_fact:
        k8s_apiserver_advertise_address: "{{ hostname_i_result.stdout_lines[0] }}"

    - name: Retrieve the Kubernetes join command from the first master
      command:
        cmd: /usr/bin/kubeadm token create --print-join-command
      register: kubeadm_join_command_result
      delegate_to: "{{ groups['k8s_master'][0] }}"

    - name: Save the Kubernetes join command
      set_fact:
        kubeadm_join_command: "{{ kubeadm_join_command_result.stdout_lines[0] }}"

    - name: Execute the command to Join the additional master to the Kubernetes cluster
      command:
        cmd: "{{ kubeadm_join_command }} --control-plane --apiserver-advertise-address={{ k8s_apiserver_advertise_address }}"

    - name: Copy the Kubernetes configuration to the root user
      block:
      - name: Create the /root/.kube directory
        file:
          path: /root/.kube
          owner: root
          group: root
          mode: 0750
          state: directory

      - name: Copy the /etc/kubernetes/admin.conf file to the /root/.kube directory
        command:
          cmd: cp /etc/kubernetes/admin.conf /root/.kube/config

      - name: Set the permissions for the /root/.kube/config file
        file:
          path: /root/.kube/config
          owner: k8s-admin
          group: k8s-admin
          mode: 0640
          state: file

    - name: Copy the Kubernetes configuration to the k8s-admin user
      block:
      - name: Create the /home/k8s-admin/.kube directory
        file:
          path: /home/k8s-admin/.kube
          owner: k8s-admin
          group: k8s-admin
          mode: 0750
          state: directory

      - name: Copy the /etc/kubernetes/admin.conf file to the /home/k8s-admin/.kube directory
        command:
          cmd: cp /etc/kubernetes/admin.conf /home/k8s-admin/.kube/config

      - name: Set the permissions for the /home/k8s-admin/.kube/config file
        file:
          path: /home/k8s-admin/.kube/config
          owner: k8s-admin
          group: k8s-admin
          mode: 0640
          state: file

    - name: Setup the kubeshell script
      block:
      - name: Create the kubeshell script
        template:
          src: kubeshell.j2
          dest: /usr/bin/kubeshell
          
      - name: Set the permissions for the kubeshell script
        file:
          path: /usr/bin/kubeshell
          owner: root
          group: root
          mode: 0770
          state: file

    - name: Allows pods to scheduled on the master if there are no worker nodes
      command:
        cmd: /usr/bin/kubectl taint node {{ inventory_hostname_short }} node-role.kubernetes.io/master:NoSchedule-
      when: ("k8s_worker" not in groups.keys())

    when: kubelet_config_stat_result.stat.exists == False
        
  when: groups['k8s_master'][0] != inventory_hostname


#  _   _ _____ _     __  __ 
# | | | | ____| |   |  \/  |
# | |_| |  _| | |   | |\/| |
# |  _  | |___| |___| |  | |
# |_| |_|_____|_____|_|  |_|
#                           
- name: Install Helm
  block:
  - debug:
      msg: Check whether the helm {{ helm_version }} package has been installed

  - stat:
      path: /usr/bin/helm
    register: helm_installed_stat_result

  - shell:
      cmd: /usr/bin/helm version --short | head -1 | awk -F '+' {'print $1'} | cut -c2-
    register: helm_installed_version_output
    when: (helm_installed_stat_result.stat.exists == True)

  - set_fact:
      helm_installed_version: '{{ helm_installed_version_output.stdout }}'
    when: (helm_installed_stat_result.stat.exists == True)

  - set_fact:
      helm_installed_version: ''
    when: (helm_installed_stat_result.stat.exists == False)

  - block:
    - debug:
        msg: Install the helm {{ helm_version }} package

    - name: Check whether the helm {{ helm_version }} package has been downloaded
      become: no
      local_action: stat path=packages/helm-v{{ helm_version }}-linux-amd64.tar.gz
      register: helm_package_stat_result  

    - name: Download the helm {{ helm_version }} package
      become: no
      local_action: get_url url='https://get.helm.sh/helm-v{{ helm_version }}-linux-amd64.tar.gz' dest='packages/helm-v{{ helm_version }}-linux-amd64.tar.gz' checksum={{ helm_package_checksum }}
      when: (helm_package_stat_result.stat.exists == False)

    - name: Remove the existing helm binary
      file:
        path: /usr/bin/helm
        state: absent

    - name: Extract the helm binary from the helm {{ helm_version }} package
      unarchive:
        src: packages/helm-v{{ helm_version }}-linux-amd64.tar.gz
        dest: /usr/bin
        extra_opts:
        - --strip-components=1
        - linux-amd64/helm
        creates: /usr/bin/helm

    when: (helm_installed_version != helm_version)

  - name: Check if the stable Helm repository has been added
    shell:
      cmd: /usr/bin/helm repo list | grep stable | wc -l
    register: helm_stable_repo_added_output

  - name: Add the stable Helm repository
    command:
      cmd: /usr/bin/helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    when: helm_stable_repo_added_output.stdout == "0"        

  - name: Check if the elastic Helm repository has been added
    shell:
      cmd: /usr/bin/helm repo list | grep elastic | wc -l
    register: helm_elastic_repo_added_output

  - name: Add the elastic Helm repository
    command:
      cmd: /usr/bin/helm repo add elastic https://helm.elastic.co
    when: helm_elastic_repo_added_output.stdout == "0"        


#  ____  _____    _    _     _____ ____    ____  _____ ____ ____  _____ _____ ____  
# / ___|| ____|  / \  | |   | ____|  _ \  / ___|| ____/ ___|  _ \| ____|_   _/ ___| 
# \___ \|  _|   / _ \ | |   |  _| | | | | \___ \|  _|| |   | |_) |  _|   | | \___ \ 
#  ___) | |___ / ___ \| |___| |___| |_| |  ___) | |__| |___|  _ <| |___  | |  ___) |
# |____/|_____/_/   \_\_____|_____|____/  |____/|_____\____|_| \_\_____| |_| |____/ 
#                                                                                   
- name: Install the Bitnami Labs Sealed Secrets Extension
  block:
  - debug:
      msg: Check whether the kubeseal {{ bitnami_labs_sealed_secrets_version }} package has been installed

  - stat:
      path: /usr/bin/kubeseal
    register: kubeseal_installed_stat_result

  - shell:
      cmd: /usr/bin/kubeseal --version |  awk -F ' ' {'print $3'} | cut -c2-
    register: kubeseal_installed_version_output
    when: (kubeseal_installed_stat_result.stat.exists == True)

  - set_fact:
      kubeseal_installed_version: '{{ kubeseal_installed_version_output.stdout }}'
    when: (kubeseal_installed_stat_result.stat.exists == True)

  - set_fact:
      kubeseal_installed_version: ''
    when: (kubeseal_installed_stat_result.stat.exists == False)

  - name: Install the Bitnami Labs kubeseal package
    block:
    - debug:
        msg: Install the Bitnami Labs kubeseal {{ bitnami_labs_sealed_secrets_version }} package

    - name: Check whether the kubeseal {{ bitnami_labs_sealed_secrets_version }} package has been downloaded
      become: no
      local_action: stat path=packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_version }}
      register: kubeseal_package_stat_result  

    - name: Download the kubeseal {{ bitnami_labs_sealed_secrets_version }} package
      become: no
      local_action: get_url url='https://github.com/bitnami-labs/sealed-secrets/releases/download/v{{ bitnami_labs_sealed_secrets_version }}/kubeseal-linux-amd64' dest='packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_version }}'
      when: (kubeseal_package_stat_result.stat.exists == False)

    - name: Remove the existing kubeseal binary
      file:
        path: /usr/bin/kubeseal
        state: absent

    - name: Copy the kubeseal binary
      copy:
        src: packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_version }}
        dest: /usr/bin
        
    - name: Rename the kubeseal binary
      command:
        cmd: mv /usr/bin/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_version }} /usr/bin/kubeseal
        creates: /usr/bin/kubeseal
        
    - name: Set the permissions for the kubeseal binary
      file:
        path: /usr/bin/kubeseal
        owner: root
        group: root
        mode: 0770
        state: file

    when: (kubeseal_installed_version != bitnami_labs_sealed_secrets_version)
    
  - shell:
      cmd: /usr/bin/kubectl -n kube-system get deployments | grep "sealed-secrets-controller" | wc -l
    register: bitnami_labs_sealed_secrets_controller_installed_output
    
  - set_fact:
      bitnami_labs_sealed_secrets_controller_installed_version: ''
    when: bitnami_labs_sealed_secrets_controller_installed_output.stdout == "0"
        
  - shell:
      cmd: /usr/bin/kubectl -n kube-system describe deployment sealed-secrets-controller | grep "Image:" | sed 's/.*:v//'
    register: bitnami_labs_sealed_secrets_controller_installed_version_output
    when: bitnami_labs_sealed_secrets_controller_installed_output.stdout == "1"

  - set_fact:
      bitnami_labs_sealed_secrets_controller_installed_version: '{{ bitnami_labs_sealed_secrets_controller_installed_version_output.stdout }}'
    when: bitnami_labs_sealed_secrets_controller_installed_output.stdout == "1"
  
  - name: Install the Bitnami Labs SealedSecret CRD and server-side controller
    block:
    - debug:
        msg: Install the Bitnami Labs SealedSecret CRD and server-side controller
        
    - name: Retrieve the Bitnami Labs SealedSecret CRD and server-side controller configuration
      get_url:
        url: https://github.com/bitnami-labs/sealed-secrets/releases/download/v{{ bitnami_labs_sealed_secrets_version }}/controller.yaml
        dest: /var/tmp/ansible/bitnami-labs-sealed-secret-controller-{{ bitnami_labs_sealed_secrets_version }}.yaml
      register: get_bitnami_labs_sealed_secret_controller_result
      until: get_bitnami_labs_sealed_secret_controller_result is succeeded
      retries: 3
      delay: 10      
    
    - name: Apply the Bitnami Labs SealedSecret CRD and server-side controller configuration
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/bitnami-labs-sealed-secret-controller-{{ bitnami_labs_sealed_secrets_version }}.yaml

    when: (bitnami_labs_sealed_secrets_controller_installed_version != bitnami_labs_sealed_secrets_version)
  
  when: ((bitnami_labs_sealed_secrets_enabled is defined) and (bitnami_labs_sealed_secrets_enabled != None) and (bitnami_labs_sealed_secrets_enabled == true))


#   ___  ____  _____ ____      _  _____ ___  ____    _     ___ _____ _____ ______   ______ _     _____   __  __    _    _   _    _    ____ _____ ____  
#  / _ \|  _ \| ____|  _ \    / \|_   _/ _ \|  _ \  | |   |_ _|  ___| ____/ ___\ \ / / ___| |   | ____| |  \/  |  / \  | \ | |  / \  / ___| ____|  _ \ 
# | | | | |_) |  _| | |_) |  / _ \ | || | | | |_) | | |    | || |_  |  _|| |    \ V / |   | |   |  _|   | |\/| | / _ \ |  \| | / _ \| |  _|  _| | |_) |
# | |_| |  __/| |___|  _ <  / ___ \| || |_| |  _ <  | |___ | ||  _| | |__| |___  | || |___| |___| |___  | |  | |/ ___ \| |\  |/ ___ \ |_| | |___|  _ < 
#  \___/|_|   |_____|_| \_\/_/   \_\_| \___/|_| \_\ |_____|___|_|   |_____\____| |_| \____|_____|_____| |_|  |_/_/   \_\_| \_/_/   \_\____|_____|_| \_\
#                                                                                                                                                      
- name: Install the Operator Lifecycle Manager if it is enabled
  block:
  
  - name: Check if the Operator Lifecycle Manager (olm) namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep olm | wc -l
    register: operator_lifecycle_manager_namespace_exists_output
  
  - block:
    - name: Generate the Operator Lifecycle Manager Custom Resource Definitions configuration
      template:
        src: operator-lifecycle-manager-crds.yaml.j2
        dest: /var/tmp/ansible/operator-lifecycle-manager-crds.yaml
        
    - name: Apply the Operator Lifecycle Manager Custom Resource Definitions configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/operator-lifecycle-manager-crds.yaml

    - name: Generate the Operator Lifecycle Manager configuration
      template:
        src: operator-lifecycle-manager-olm.yaml.j2
        dest: /var/tmp/ansible/operator-lifecycle-manager-olm.yaml
  
    - name: Apply the Operator Lifecycle Manager configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/operator-lifecycle-manager-olm.yaml
        
    - name: Wait for the Operator Lifecycle Manager olm-operator deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n olm rollout status -w deployment/olm-operator
      register: wait_for_olm_operator_deployment_result
      until: wait_for_olm_operator_deployment_result is succeeded
      retries: 60
      delay: 10      

    - name: Wait for the Operator Lifecycle Manager catalog-operator deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n olm rollout status -w deployment/catalog-operator
      register: wait_for_catalog_operator_deployment_result
      until: wait_for_catalog_operator_deployment_result is succeeded
      retries: 60
      delay: 10    
    
    when: operator_lifecycle_manager_namespace_exists_output.stdout == "0"        
 
  when: ((operator_lifecycle_manager_enabled is defined) and (operator_lifecycle_manager_enabled != None) and (operator_lifecycle_manager_enabled == true))


#  ____   ___  ____ _____ ____ ____  _____ ____     ___  ____  _____ ____      _  _____ ___  ____  
# |  _ \ / _ \/ ___|_   _/ ___|  _ \| ____/ ___|   / _ \|  _ \| ____|  _ \    / \|_   _/ _ \|  _ \ 
# | |_) | | | \___ \ | || |  _| |_) |  _| \___ \  | | | | |_) |  _| | |_) |  / _ \ | || | | | |_) |
# |  __/| |_| |___) || || |_| |  _ <| |___ ___) | | |_| |  __/| |___|  _ <  / ___ \| || |_| |  _ < 
# |_|    \___/|____/ |_| \____|_| \_\_____|____/   \___/|_|   |_____|_| \_\/_/   \_\_| \___/|_| \_\
#                                                                                                  
- name: Install the Postgres Operator if it is enabled
  block:
  
  - name: Check if Postgres Operator is installed
    shell:
      cmd: /usr/bin/kubectl get subscription -n operators 2>&1 | grep postgres-operator | wc -l
    register: postgres_operator_installed_output
    
  - block:
    - name: Generate the Postgres Operator configuration
      template:
        src: postgres-operator.yaml.j2
        dest: /var/tmp/ansible/postgres-operator.yaml
      
    - name: Apply the Postgres Operator configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/postgres-operator.yaml
        
    - name: Wait for the Postgres Operator deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n operators rollout status -w deployment/postgres-operator
      register: wait_for_postgres_operator_deployment_result
      until: wait_for_postgres_operator_deployment_result is succeeded
      retries: 30
      delay: 10    
    
    when: postgres_operator_installed_output.stdout == "0"
  
  when: ((postgres_operator_enabled is defined) and (postgres_operator_enabled != None) and (postgres_operator_enabled == true))


#  _     ___  _   _  ____ _   _  ___  ____  _   _ 
# | |   / _ \| \ | |/ ___| | | |/ _ \|  _ \| \ | |
# | |  | | | |  \| | |  _| |_| | | | | |_) |  \| |
# | |__| |_| | |\  | |_| |  _  | |_| |  _ <| |\  |
# |_____\___/|_| \_|\____|_| |_|\___/|_| \_\_| \_|
#                                                 
- name: Install Longhorn if it is enabled
  block:

  - name: Check if the longhorn-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep longhorn-system | wc -l
    register: longhorn_system_namespace_exists_output

  - block:
    - template:
        src: longhorn.yaml.j2
        dest: /var/tmp/ansible/longhorn.yaml

    - name: Apply the Longhorn configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/longhorn.yaml
        
    - name: Wait for the Longhorn compatible-csi-attacher deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/compatible-csi-attacher
      register: wait_for_longhorn_compatible_csi_attacher_deployment_result
      until: wait_for_longhorn_compatible_csi_attacher_deployment_result is succeeded
      retries: 60
      delay: 10    
        
    - name: Wait for the Longhorn csi-attacher deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/csi-attacher
      register: wait_for_longhorn_csi_attacher_deployment_result
      until: wait_for_longhorn_csi_attacher_deployment_result is succeeded
      retries: 60
      delay: 10    
        
    - name: Wait for the Longhorn csi-provisioner deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/csi-provisioner
      register: wait_for_longhorn_csi_provisioner_deployment_result
      until: wait_for_longhorn_csi_provisioner_deployment_result is succeeded
      retries: 60
      delay: 10    

    - name: Wait for the Longhorn longhorn-driver-deployer deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/longhorn-driver-deployer
      register: wait_for_longhorn_driver_deployer_deployment_result
      until: wait_for_longhorn_driver_deployer_deployment_result is succeeded
      retries: 60
      delay: 10    

    - name: Wait for the Longhorn longhorn-ui deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/longhorn-ui
      register: wait_for_longhorn_ui_deployment_result
      until: wait_for_longhorn_ui_deployment_result is succeeded
      retries: 60
      delay: 10
  
    when: longhorn_system_namespace_exists_output.stdout == "0"

  when: ((longhorn_enabled is defined) and (longhorn_enabled != None) and (longhorn_enabled == true))


#  _____ ___  ____   ___  _ __     ____  __ 
# |_   _/ _ \|  _ \ / _ \| |\ \   / /  \/  |
#   | || | | | |_) | | | | | \ \ / /| |\/| |
#   | || |_| |  __/| |_| | |__\ V / | |  | |
#   |_| \___/|_|    \___/|_____\_/  |_|  |_|
#                                           
- name: Install the TopoLVM CSI plugin
  block:
  
  - name: Check if the topolvm-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep topolvm-system | wc -l
    register: topolvm_system_namespace_exists_output    

  - block:
    - set_fact:
        topolvm_mutatingwebhook_key: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/k8s-' + k8s_cluster_name + '-topolvm-mutatingwebhook.key') | b64encode }}"
        
    - set_fact:
        topolvm_mutatingwebhook_crt: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/k8s-' + k8s_cluster_name + '-topolvm-mutatingwebhook.crt') | b64encode }}"

    - set_fact:
        topolvm_mutatingwebhook_ca_bundle: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/ca-bundle.crt') | b64encode }}"
  
    - name: Generate the initial TopoLVM configuration
      template:
        src: topolvm-init.yaml.j2
        dest: /var/tmp/ansible/topolvm-init.yaml
        
    - name: Apply the initial TopoLVM configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-init.yaml
        
    - name: Disable the TopoLVM mutating webhook for the kube-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns kube-system topolvm.cybozu.com/webhook=ignore

    - name: Disable the TopoLVM mutating webhook for the longhorn-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns longhorn-system topolvm.cybozu.com/webhook=ignore
      when: ((longhorn_enabled is defined) and (longhorn_enabled != None) and (longhorn_enabled == true))

    - name: Disable the TopoLVM mutating webhook for the olm namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns olm topolvm.cybozu.com/webhook=ignore
      when: ((operator_lifecycle_manager_enabled is defined) and (operator_lifecycle_manager_enabled != None) and (operator_lifecycle_manager_enabled == true))

    - name: Generate the TopoLVM Custom Resource Definition configuration
      template:
        src: topolvm-crd.yaml.j2
        dest: /var/tmp/ansible/topolvm-crd.yaml
    
    - name: Apply the TopoLVM Custom Resource Definition configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-crd.yaml

    - name: Generate the TopoLVM Pod Security Policy configuration
      template:
        src: topolvm-psp.yaml.j2
        dest: /var/tmp/ansible/topolvm-psp.yaml

    - name: Apply the TopoLVM Pod Security Policy configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-psp.yaml

    - name: Generate the TopoLVM Scheduler daemonset configuration
      template:
        src: topolvm-scheduler-daemonset.yaml.j2
        dest: /var/tmp/ansible/topolvm-scheduler.yaml
      when: ("k8s_master" in groups.keys())
        
    - name: Generate the TopoLVM Scheduler service configuration
      template:
        src: topolvm-scheduler-service.yaml.j2
        dest: /var/tmp/ansible/topolvm-scheduler.yaml
      when: ("k8s_master" not in groups.keys())
        
    - name: Apply the TopoLVM Scheduler configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-scheduler.yaml

    - name: Generate the TopoLVM Mutating Webhooks configuration
      template:
        src: topolvm-mutatingwebhooks.yaml.j2
        dest: /var/tmp/ansible/topolvm-mutatingwebhooks.yaml
    
    - name: Apply the TopoLVM Mutating Webhooks configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-mutatingwebhooks.yaml

    - name: Generate the TopoLVM Controller configuration
      template:
        src: topolvm-controller.yaml.j2
        dest: /var/tmp/ansible/topolvm-controller.yaml
    
    - name: Apply the TopoLVM Controller configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-controller.yaml
        
    - name: Wait for the TopoLVM controller deployment to complete
      command: 
        cmd: /usr/bin/kubectl -n topolvm-system rollout status -w deployment/controller
      register: wait_for_topo_lvm_controller_deployment_result
      until: wait_for_topo_lvm_controller_deployment_result is succeeded
      retries: 60
      delay: 10    
    
    - name: Generate the TopoLVM Node configuration    
      template:
        src: topolvm-node.yaml.j2
        dest: /var/tmp/ansible/topolvm-node.yaml
    
    - name: Apply the TopoLVM Node configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-node.yaml
        
    - name: Generate the TopoLVM Provisioner configuration    
      template:
        src: topolvm-provisioner.yaml.j2
        dest: /var/tmp/ansible/topolvm-provisioner.yaml
    
    - name: Apply the TopoLVM Provisioner configuration to Kubernetes
      command: 
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-provisioner.yaml
        
    when: topolvm_system_namespace_exists_output.stdout == "0"        

  when: ((topolvm_enabled is defined) and (topolvm_enabled != None) and (topolvm_enabled == true))


#  __  __  ___  _   _ ___ _____ ___  ____  ___ _   _  ____ 
# |  \/  |/ _ \| \ | |_ _|_   _/ _ \|  _ \|_ _| \ | |/ ___|
# | |\/| | | | |  \| || |  | || | | | |_) || ||  \| | |  _ 
# | |  | | |_| | |\  || |  | || |_| |  _ < | || |\  | |_| |
# |_|  |_|\___/|_| \_|___| |_| \___/|_| \_\___|_| \_|\____|
#                     
- name: Configure the monitoring components
  block:
  - name: Create the monitoring-system namespace
    shell:
      cmd: /usr/bin/kubectl create namespace monitoring-system --dry-run -o yaml | kubectl apply -f -
      
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true))


#  _____ _        _    ____ _____ ___ ____ ____  _____    _    ____   ____ _   _ 
# | ____| |      / \  / ___|_   _|_ _/ ___/ ___|| ____|  / \  |  _ \ / ___| | | |
# |  _| | |     / _ \ \___ \ | |  | | |   \___ \|  _|   / _ \ | |_) | |   | |_| |
# | |___| |___ / ___ \ ___) || |  | | |___ ___) | |___ / ___ \|  _ <| |___|  _  |
# |_____|_____/_/   \_\____/ |_| |___\____|____/|_____/_/   \_\_| \_\\____|_| |_|
#                                                                                
- name: Install and configure Elasticsearch if it is enabled
  block:
  - name: Configure the Elasticsearch certificates and secrets if security is enabled
    block:
    - name: Create the /var/tmp/ansible/elasticsearch-pki directory
      file:
        path: /var/tmp/ansible/elasticsearch-pki
        state: directory

    - name: Copy the root CA certificate to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/ca.crt
        dest: /var/tmp/ansible/elasticsearch-pki/ca.pem

    - name: Copy the Elasticsearch private key to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-elasticsearch.key
        dest: /var/tmp/ansible/elasticsearch-pki/elasticsearch-key.pem

    - name: Copy the Elasticsearch certificate to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-elasticsearch.crt
        dest: /var/tmp/ansible/elasticsearch-pki/elasticsearch-cert.pem
    
    - name: Create the secret in the monitoring-system namespace for the Elasticsearch private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n monitoring-system secret generic elasticsearch-certs --from-file=/var/tmp/ansible/elasticsearch-pki/elasticsearch-key.pem --from-file=/var/tmp/ansible/elasticsearch-pki/elasticsearch-cert.pem --from-file=/var/tmp/ansible/elasticsearch-pki/ca.pem --dry-run -o yaml | kubectl apply -f -
            
    - name: Check if the Elasticsearch credentials secret exists
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep elasticsearch-credentials | wc -l
      register: elasticsearch_credentials_secret_exists_output
  
    - name: Create the Elasticsearch credentials secret if it does not exist
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system create secret generic elasticsearch-credentials --from-literal=username=elastic --from-literal=password=`tr -cd '[:alnum:]' < /dev/urandom | fold -w30 | head -n1` --dry-run -o yaml | kubectl apply -f -
      when: (elasticsearch_credentials_secret_exists_output.stdout == "0")
    
    - name: Retrieve the Elasticsearch password
      block:
      - shell:
          cmd: /usr/bin/kubectl -n monitoring-system get secret elasticsearch-credentials -o=jsonpath='{.data.password}' | base64 --decode
        register: retrieve_elasticsearch_credentials_password_output
  
      - set_fact:
          elasticsearch_credentials_password: '{{ retrieve_elasticsearch_credentials_password_output.stdout }}'
    
      - debug:
          msg: "Elasticsearch Password: {{ elasticsearch_credentials_password }}"
          
    when: ((monitoring_security_enabled is defined) and (monitoring_security_enabled != None) and (monitoring_security_enabled == True))
  
  - name: Install a single node Elasticsearch cluster using Helm
    block:
    - name: Check if Elasticsearch is installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_installed_helm_chart_version_output
  
    - name: Install Elasticsearch
      block:  
      - name: Generate the Elasticsearch Helm values
        template:
          src: elasticsearch-standalone-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-standalone-values.yaml

      - name: Install Elasticsearch using Helm
        command: 
          cmd: /usr/bin/helm upgrade elasticsearch elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-standalone-values.yaml        
      when: elasticsearch_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version
    when: (monitoring_elasticsearch_cluster_type == "standalone")

  - name: Install a multi node Elasticsearch cluster using Helm
    block:
    - name: Check if the Elasticsearch master nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-master" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_master_installed_helm_chart_version_output
  
    - name: Install the Elasticsearch master nodes
      block:  
      - name: Generate the master nodes Elasticsearch Helm values
        template:
          src: elasticsearch-master-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-master-values.yaml

      - name: Install the Elasticsearch master nodes using Helm
        command: 
          cmd: /usr/bin/helm upgrade elasticsearch-master elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-master-values.yaml        
      when: elasticsearch_master_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version
      
    - name: Check if the Elasticsearch ingest nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-ingest" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_ingest_installed_helm_chart_version_output
  
    - name: Install the Elasticsearch ingest nodes
      block:  
      - name: Generate the ingest nodes Elasticsearch Helm values
        template:
          src: elasticsearch-ingest-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-ingest-values.yaml

      - name: Install the Elasticsearch ingest nodes using Helm
        command: 
          cmd: /usr/bin/helm upgrade elasticsearch-ingest elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-ingest-values.yaml        
      when: elasticsearch_ingest_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version
      
    - name: Check if the Elasticsearch data nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-data" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_data_installed_helm_chart_version_output
  
    - name: Install the Elasticsearch data nodes
      block:  
      - name: Generate the data nodes Elasticsearch Helm values
        template:
          src: elasticsearch-data-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-data-values.yaml

      - name: Install the Elasticsearch data nodes using Helm
        command: 
          cmd: /usr/bin/helm upgrade elasticsearch-data elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-data-values.yaml        
      when: elasticsearch_data_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version
      
    when: ((monitoring_elasticsearch_cluster_type == "minimal") or (monitoring_elasticsearch_cluster_type == "full"))
    
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true))


#  _  _____ ____    _    _   _    _    
# | |/ /_ _| __ )  / \  | \ | |  / \   
# | ' / | ||  _ \ / _ \ |  \| | / _ \  
# | . \ | || |_) / ___ \| |\  |/ ___ \ 
# |_|\_\___|____/_/   \_\_| \_/_/   \_\
#                                      
- name: Install and configure Kibana if it is enabled
  block:
  - name: Configure the Kibana certificates and secrets if security is enabled
    block:
    - name: Create the /var/tmp/ansible/kibana-pki directory
      file:
        path: /var/tmp/ansible/kibana-pki
        state: directory

    - name: Copy the root CA certificate to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/ca.crt
        dest: /var/tmp/ansible/kibana-pki/ca.pem

    - name: Copy the Kibana private key to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-kibana.key
        dest: /var/tmp/ansible/kibana-pki/kibana-key.pem

    - name: Copy the Kibana certificate to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-kibana.crt
        dest: /var/tmp/ansible/kibana-pki/kibana-cert.pem
    
    - name: Create the secret in the monitoring-system namespace for the Kibana private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n monitoring-system secret generic kibana-certs --from-file=/var/tmp/ansible/kibana-pki/kibana-key.pem --from-file=/var/tmp/ansible/kibana-pki/kibana-cert.pem --from-file=/var/tmp/ansible/kibana-pki/ca.pem --dry-run -o yaml | kubectl apply -f -
    
    - name: Check if the Kibana Elasticsearch credentials secret exists
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep kibana-elasticsearch-credentials | wc -l
      register: kibana_elasticsearch_credentials_secret_exists_output
  
    - name: Create the Kibana Elasticsearch credentials secret if it does not exist
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system create secret generic kibana-elasticsearch-credentials --from-literal=username=elastic --from-literal=password={{ elasticsearch_credentials_password }} --dry-run -o yaml | kubectl apply -f -
      when: (kibana_elasticsearch_credentials_secret_exists_output.stdout == "0")
              
    when: ((monitoring_security_enabled is defined) and (monitoring_security_enabled != None) and (monitoring_security_enabled == True))
  
  - name: Check if Kibana is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "kibana" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: kibana_installed__helm_chart_version_output
  
  - name: Install Kibana
    block:  
    - name: Generate the Kibana Helm values
      template:
        src: kibana-values.yaml.j2
        dest: /var/tmp/ansible/kibana-values.yaml
      
    - name: Install Kibana using Helm
      command: 
        cmd: /usr/bin/helm upgrade kibana elastic/kibana --install --version={{ monitoring_kibana_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/kibana-values.yaml
            
    when: kibana_installed__helm_chart_version_output.stdout != monitoring_kibana_helm_chart_version
  
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true) and (monitoring_kibana_enabled is defined) and (monitoring_kibana_enabled != None) and (monitoring_kibana_enabled == true))


#      _   _    _____ ____ _____ ____  
#     | | / \  | ____/ ___| ____|  _ \ 
#  _  | |/ _ \ |  _|| |  _|  _| | |_) |
# | |_| / ___ \| |__| |_| | |___|  _ < 
#  \___/_/   \_\_____\____|_____|_| \_\
#                                      
- name: Install and configure Jaeger if it is enabled
  block:
  - name: Create the secret for the Jaeger Elasticsearch user
    shell:
      cmd: "/usr/bin/kubectl -n monitoring-system create secret generic monitoring-jaeger-elastic-user --from-literal=ES_PASSWORD={{ elasticsearch_credentials_password }} --from-literal=ES_USERNAME=elastic --dry-run -o yaml | kubectl apply -f -"
    
  - name: Generate the Jaeger configuration    
    template:
      src: jaeger.yaml.j2
      dest: /var/tmp/ansible/jaeger.yaml

  - name: Apply the Jaeger configuration to Kubernetes
    command: 
      cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/jaeger.yaml

  - name: Wait for the Jaeger configuration to be applied
    block:
    - command: 
        cmd: /usr/bin/kubectl -n monitoring-system get jaeger/monitoring-jaeger
      register: wait_for_jaeger_configuration_result
      until: wait_for_jaeger_configuration_result is succeeded
      retries: 60
      delay: 10

    - shell:
        cmd: /usr/bin/kubectl -n monitoring-system get jaeger/monitoring-jaeger | head -2 | tail -1 | awk  {'print $2'}
      register: jaeger_status_output
      until: jaeger_status_output.stdout == "Running"
      retries: 60
      delay: 10 
  
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true) and (monitoring_jaeger_enabled is defined) and (monitoring_jaeger_enabled != None) and (monitoring_jaeger_enabled == true))


#  ____  ____   ___  __  __ _____ _____ _   _ _____ _   _ ____  
# |  _ \|  _ \ / _ \|  \/  | ____|_   _| | | | ____| | | / ___| 
# | |_) | |_) | | | | |\/| |  _|   | | | |_| |  _| | | | \___ \ 
# |  __/|  _ <| |_| | |  | | |___  | | |  _  | |___| |_| |___) |
# |_|   |_| \_\\___/|_|  |_|_____| |_| |_| |_|_____|\___/|____/ 
#                                                               
- name: Install and configure Prometheus if it is enabled
  block:
  - name: Check if Prometheus is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "prometheus" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: prometheus_installed__helm_chart_version_output
  
  - name: Install Prometheus
    block:  
    - name: Generate the Prometheus Helm values
      template:
        src: prometheus-values.yaml.j2
        dest: /var/tmp/ansible/prometheus-values.yaml
      
    - name: Install Prometheus using Helm
      command: 
        cmd: /usr/bin/helm upgrade prometheus stable/prometheus --install --version={{ monitoring_prometheus_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/prometheus-values.yaml
            
    when: prometheus_installed__helm_chart_version_output.stdout != monitoring_prometheus_helm_chart_version
    
  - name: Generate the Prometheus Server configuration
    template:
      src: prometheus-server-config-map.yaml.j2
      dest: /var/tmp/ansible/prometheus-server-config-map.yaml
    
  - name: Apply the Prometheus Server configuration to Kubernetes
    command: 
      cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/prometheus-server-config-map.yaml
        
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_prometheus_enabled is defined) and (monitoring_prometheus_enabled != None) and (monitoring_prometheus_enabled == true))


#   ____ ____      _    _____ _    _   _    _    
#  / ___|  _ \    / \  |  ___/ \  | \ | |  / \   
# | |  _| |_) |  / _ \ | |_ / _ \ |  \| | / _ \  
# | |_| |  _ <  / ___ \|  _/ ___ \| |\  |/ ___ \ 
#  \____|_| \_\/_/   \_\_|/_/   \_\_| \_/_/   \_\
#                                                
- name: Install and configure Grafana if it is enabled
  block:
  - name: Configure the Grafana certificates and secrets
    block:
      - name: Check if the Grafana admin credentials secret exists
        shell:
          cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep grafana-admin-credentials | wc -l
        register: grafana_admin_credentials_secret_exists_output
  
      - name: Create the Grafana admin credentials secret if it does not exist
        shell:
          cmd: /usr/bin/kubectl -n monitoring-system create secret generic grafana-admin-credentials --from-literal=username=admin --from-literal=password=admin --dry-run -o yaml | kubectl apply -f -
        when: (grafana_admin_credentials_secret_exists_output.stdout == "0")
  
  - name: Check if Grafana is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "grafana" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: grafana_installed_helm_chart_version_output
  
  - name: Install Grafana
    block:  
    - name: Generate the Grafana Helm values
      template:
        src: grafana-values.yaml.j2
        dest: /var/tmp/ansible/grafana-values.yaml
      
    - name: Install Grafana using Helm
      command: 
        cmd: /usr/bin/helm upgrade grafana stable/grafana --install --version={{ monitoring_grafana_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/grafana-values.yaml
  
    when: grafana_installed_helm_chart_version_output.stdout != monitoring_grafana_helm_chart_version

  - name: Generate and install the Grafana Istio dashboard ConfigMaps
    block:
    - name: Generate the Grafana Istio dashboard ConfigMaps
      template:
        src: istio-grafana-dashboard-config-maps.yaml.j2
        dest: /var/tmp/ansible/istio-grafana-dashboard-config-maps.yaml
    
    - name: Install the Grafana Istio dashboard ConfigMaps
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-grafana-dashboard-config-maps.yaml

    when: ((istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))

  - name: Retrieve the grafana admin username and password
    block:
    - shell:
        cmd: kubectl -n monitoring-system get secret grafana-admin-credentials -o=jsonpath='{.data.username}' | base64 --decode
      register: grafana_admin_username_output
    
    - debug:
        msg: "Grafana Admin Username: {{ grafana_admin_username_output.stdout }}"

    - shell:
        cmd: kubectl -n monitoring-system get secret grafana-admin-credentials -o=jsonpath='{.data.password}' | base64 --decode
      register: grafana_admin_password_output
    
    - debug:
        msg: "Grafana Admin Password: {{ grafana_admin_password_output.stdout }}"
      
      
  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_grafana_enabled is defined) and (monitoring_grafana_enabled != None) and (monitoring_grafana_enabled == true))


#  ___ ____ _____ ___ ___  
# |_ _/ ___|_   _|_ _/ _ \ 
#  | |\___ \ | |  | | | | |
#  | | ___) || |  | | |_| |
# |___|____/ |_| |___\___/ 
#                          
- name: Install istioctl
  block:
  - debug:
      msg: Check whether the istioctl {{ istio_version }} package has been installed

  - stat:
      path: /usr/bin/istioctl
    register: istioctl_installed_stat_result

  - shell:
      cmd: /usr/bin/istioctl version --remote=false
    register: istioctl_installed_version_output
    when: (istioctl_installed_stat_result.stat.exists == True)

  - set_fact:
      istioctl_installed_version: '{{ istioctl_installed_version_output.stdout }}'
    when: (istioctl_installed_stat_result.stat.exists == True)

  - set_fact:
      istioctl_installed_version: ''
    when: (istioctl_installed_stat_result.stat.exists == False)

  - block:
    - debug:
        msg: Install the istioctl {{ istio_version }} package
        
    - name: Check whether the istioctl {{ istio_version }} package has been downloaded
      become: no
      local_action: stat path=packages/istioctl-{{ istio_version }}-linux.tar.gz
      register: istioctl_package_stat_result  

    - name: Download the istioctl {{ istio_version }} package
      become: no
      local_action: get_url url='https://github.com/istio/istio/releases/download/{{ istio_version }}/istioctl-{{ istio_version }}-linux.tar.gz' dest='packages/istioctl-{{ istio_version }}-linux.tar.gz' checksum={{ istioctl_package_checksum }}
      when: (istioctl_package_stat_result.stat.exists == False)

    - name: Remove the existing istioctl binary
      file:
        path: /usr/bin/istioctl
        state: absent

    - name: Extract the istioctl binary from the istioctl {{ istio_version }} package
      unarchive:
        src: packages/istioctl-{{ istio_version }}-linux.tar.gz
        dest: /usr/bin
        creates: /usr/bin/istioctl

    when: (istioctl_installed_version != istio_version)

  when: ((istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))

- name: Initialize the Istio service mesh
  block:
  - name: Download and extract the Istio package if required
    block:
    - name: Check whether the istio {{ istio_version }} package has been downloaded
      become: no
      local_action: stat path=packages/istio-{{ istio_version }}-linux.tar.gz
      register: istio_package_stat_result  

    - name: Download the istio {{ istio_version }} package
      become: no
      local_action: get_url url='https://github.com/istio/istio/releases/download/{{ istio_version }}/istio-{{ istio_version }}-linux.tar.gz' dest='packages/istio-{{ istio_version }}-linux.tar.gz' checksum={{ istio_package_checksum }}
      when: (istio_package_stat_result.stat.exists == False)

    - name: Extract the istio {{ istio_version }} package
      unarchive:
        src: packages/istio-{{ istio_version }}-linux.tar.gz
        dest: /var/tmp/ansible
        creates: /var/tmp/ansible/istio-{{ istio_version }}
  
  - name: Check if the istio-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep istio-system | wc -l
    register: istio_system_namespace_exists_output

  - name: Install and configure the Istio service mesh
    block:
    - name: Copying the keys and certificates for the Istio service mesh
      block:
      - name: Create the /var/tmp/ansible/istio-pki directory
        file:
          path: /var/tmp/ansible/istio-pki
          state: directory

      - name: Copy the Istio intermediate CA private key to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca.key
          dest: /var/tmp/ansible/istio-pki/ca-key.pem

      - name: Copy the Istio intermediate CA certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca.crt
          dest: /var/tmp/ansible/istio-pki/ca-cert.pem

      - name: Copy the Root CA certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/ca.crt
          dest: /var/tmp/ansible/istio-pki/root-cert.pem

      - name: Copy the Istio intermediate CA certificate chain to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca-chain.crt
          dest: /var/tmp/ansible/istio-pki/cert-chain.pem

      - name: Copy the Istio ingress gateway private key to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ingressgateway.key
          dest: /var/tmp/ansible/istio-pki/ingressgateway-key.pem

      - name: Copy the Istio ingress gateway certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ingressgateway.crt
          dest: /var/tmp/ansible/istio-pki/ingressgateway-cert.pem
    
    - name: Create the istio-system namespace
      shell:
        cmd: /usr/bin/kubectl create ns istio-system --dry-run -o yaml | kubectl apply -f -

    - name: Disable the TopoLVM mutating webhook for the istio-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns istio-system topolvm.cybozu.com/webhook=ignore
      when: ((topolvm_enabled is defined) and (topolvm_enabled != None) and (topolvm_enabled == true))

    - name: Create the secret in the istio-system namespace for the Istio intermediate CA private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret generic cacerts  --from-file=/var/tmp/ansible/istio-pki/ca-cert.pem --from-file=/var/tmp/ansible/istio-pki/ca-key.pem --from-file=/var/tmp/ansible/istio-pki/root-cert.pem --from-file=/var/tmp/ansible/istio-pki/cert-chain.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Create the secret in the istio-system namespace for the Istio ingress gateway private key and certificate
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret tls istio-ingressgateway-certs --key=/var/tmp/ansible/istio-pki/ingressgateway-key.pem --cert=/var/tmp/ansible/istio-pki/ingressgateway-cert.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Create the secret in the istio-system namespace for the Istio ingress gateway CA certificate
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret generic istio-ingressgateway-ca-certs --from-file=/var/tmp/ansible/istio-pki/root-cert.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Initialize the Kiali secret
      block:
      - template:
          src: istio-kiali-secret.yaml.j2
          dest: /var/tmp/ansible/istio-kiali-secret.yaml

      - name: Create the Kiali secret
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-kiali-secret.yaml

      when: ((istio_kiali_enabled is defined) and (istio_kiali_enabled != None) and (istio_kiali_enabled == true))

    - name: Create the Istio configuration file
      template:
        src: istio-config.yaml.j2
        dest: /var/tmp/ansible/istio-config.yaml

    - name: Initialize the Istio service mesh
      shell:
        cmd: /usr/bin/istioctl manifest apply -f /var/tmp/ansible/istio-config.yaml

    - name: Wait for the Istio service mesh initialization to complete
      command:
        cmd: /usr/bin/kubectl wait --namespace=istio-system --for=condition=Ready pods --all --timeout=900s
      when: ("k8s_worker" not in groups.keys())

    - block:
      - template:
          src: istio-jaeger-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-jaeger-ingress.yaml

      - name: Enable ingress for Jaeger
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-jaeger-ingress.yaml

      when: (((istio_tracing_enabled is defined) and (istio_tracing_enabled != None) and (istio_tracing_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_jaeger_enabled is defined) and (monitoring_jaeger_enabled != None) and (monitoring_jaeger_enabled == True)))

    - block:
      - template:
          src: istio-kiali-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-kiali-ingress.yaml

      - name: Enable ingress for Kiali
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-kiali-ingress.yaml

      when: ((istio_kiali_enabled is defined) and (istio_kiali_enabled != None) and (istio_kiali_enabled == true))

    - block:
      - template:
          src: istio-grafana-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-grafana-ingress.yaml

      - name: Enable ingress for Grafana
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-grafana-ingress.yaml

      when: (((istio_grafana_enabled is defined) and (istio_grafana_enabled != None) and (istio_grafana_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_grafana_enabled is defined) and (monitoring_grafana_enabled != None) and (monitoring_grafana_enabled == True)))

    - block:
      - template:
          src: istio-prometheus-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-prometheus-ingress.yaml

      - name: Enable ingress for Prometheus
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-prometheus-ingress.yaml

      when: (((istio_prometheus_enabled is defined) and (istio_prometheus_enabled != None) and (istio_prometheus_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_prometheus_enabled is defined) and (monitoring_prometheus_enabled != None) and (monitoring_prometheus_enabled == True)))

    when: istio_system_namespace_exists_output.stdout == "0"

  when: ((groups['k8s_master'][0] == inventory_hostname) and (istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))






# Delete the Postgres operator
# kubectl delete -f /var/tmp/ansible/postgres-operator.yaml 
# kubectl delete clusterserviceversion -n operators postgres-operator.v1.3.0

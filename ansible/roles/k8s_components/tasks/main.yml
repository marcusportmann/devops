# file: roles/k8s_components/tasks/main.yaml

#  _   _ _____ _     __  __   ____  _____ ____   ___  ____
# | | | | ____| |   |  \/  | |  _ \| ____|  _ \ / _ \/ ___|
# | |_| |  _| | |   | |\/| | | |_) |  _| | |_) | | | \___ \
# |  _  | |___| |___| |  | | |  _ <| |___|  __/| |_| |___) |
# |_| |_|_____|_____|_|  |_| |_| \_\_____|_|    \___/|____/
#
- name: Configure the Helm repos
  block:
  - name: Check if the stable Helm repository has been added
    shell:
      cmd: /usr/bin/helm repo list | grep stable | wc -l
    register: helm_stable_repo_added_output

  - name: Add the stable Helm repository
    command:
      cmd: /usr/bin/helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    when: helm_stable_repo_added_output.stdout == "0"

  - name: Check if the elastic Helm repository has been added
    shell:
      cmd: /usr/bin/helm repo list | grep elastic | wc -l
    register: helm_elastic_repo_added_output

  - name: Add the elastic Helm repository
    command:
      cmd: /usr/bin/helm repo add elastic https://helm.elastic.co
    when: helm_elastic_repo_added_output.stdout == "0"

  - name: Check if the jaegertracing Helm repository has been added
    shell:
      cmd: /usr/bin/helm repo list | grep jaegertracing | wc -l
    register: helm_jaegertracing_repo_added_output

  - name: Add the jaegertracing Helm repository
    command:
      cmd: /usr/bin/helm repo add jaegertracing https://jaegertracing.github.io/helm-charts
    when: helm_jaegertracing_repo_added_output.stdout == "0"


#  ____  _____    _    _     _____ ____    ____  _____ ____ ____  _____ _____ ____
# / ___|| ____|  / \  | |   | ____|  _ \  / ___|| ____/ ___|  _ \| ____|_   _/ ___|
# \___ \|  _|   / _ \ | |   |  _| | | | | \___ \|  _|| |   | |_) |  _|   | | \___ \
#  ___) | |___ / ___ \| |___| |___| |_| |  ___) | |__| |___|  _ <| |___  | |  ___) |
# |____/|_____/_/   \_\_____|_____|____/  |____/|_____\____|_| \_\_____| |_| |____/
#
- name: Install the Bitnami Labs Sealed Secrets Extension
  block:
  - debug:
      msg: Check whether the kubeseal {{ bitnami_labs_sealed_secrets_kubeseal_version }} package has been installed

  - stat:
      path: /usr/bin/kubeseal
    register: kubeseal_installed_stat_result

  - shell:
      cmd: /usr/bin/kubeseal --version |  awk -F ' ' {'print $3'} | cut -c2-
    register: kubeseal_installed_version_output
    when: (kubeseal_installed_stat_result.stat.exists == True)

  - set_fact:
      kubeseal_installed_version: '{{ kubeseal_installed_version_output.stdout }}'
    when: (kubeseal_installed_stat_result.stat.exists == True)

  - set_fact:
      kubeseal_installed_version: ''
    when: (kubeseal_installed_stat_result.stat.exists == False)

  - name: Install the Bitnami Labs kubeseal package
    block:
    - debug:
        msg: Install the Bitnami Labs kubeseal {{ bitnami_labs_sealed_secrets_kubeseal_version }} package

    - name: Check whether the kubeseal {{ bitnami_labs_sealed_secrets_kubeseal_version }} package has been downloaded
      become: no
      local_action: stat path=packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_kubeseal_version }}
      register: kubeseal_package_stat_result

    - name: Download the kubeseal {{ bitnami_labs_sealed_secrets_kubeseal_version }} package
      become: no
      local_action: get_url url='https://github.com/bitnami-labs/sealed-secrets/releases/download/v{{ bitnami_labs_sealed_secrets_kubeseal_version }}/kubeseal-linux-amd64' dest='packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_kubeseal_version }}'
      when: (kubeseal_package_stat_result.stat.exists == False)

    - name: Remove the existing kubeseal binary
      file:
        path: /usr/bin/kubeseal
        state: absent

    - name: Copy the kubeseal binary
      copy:
        src: packages/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_kubeseal_version }}
        dest: /usr/bin

    - name: Rename the kubeseal binary
      command:
        cmd: mv /usr/bin/kubeseal-linux-amd64-{{ bitnami_labs_sealed_secrets_kubeseal_version }} /usr/bin/kubeseal
        creates: /usr/bin/kubeseal

    - name: Set the permissions for the kubeseal binary
      file:
        path: /usr/bin/kubeseal
        owner: root
        group: root
        mode: 0770
        state: file

    when: (kubeseal_installed_version != bitnami_labs_sealed_secrets_kubeseal_version)

  - name: Check if Bitnami Labs Sealed Secrets is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "sealed-secrets" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: sealed_secrets_installed__helm_chart_version_output

  - name: Install Bitnami Labs Sealed Secrets
    block:
    - name: Generate the Bitnami Labs Sealed Secrets Helm values
      template:
        src: sealed-secrets-values.yaml.j2
        dest: /var/tmp/ansible/sealed-secrets-values.yaml

    - name: Install Bitnami Labs Sealed Secrets using Helm
      command:
        cmd: /usr/bin/helm upgrade sealed-secrets stable/sealed-secrets --install --version={{ bitnami_labs_sealed_secrets_helm_chart_version }} --namespace=kube-system --values=/var/tmp/ansible/sealed-secrets-values.yaml

    when: sealed_secrets_installed__helm_chart_version_output.stdout != bitnami_labs_sealed_secrets_helm_chart_version

  when: ((bitnami_labs_sealed_secrets_enabled is defined) and (bitnami_labs_sealed_secrets_enabled != None) and (bitnami_labs_sealed_secrets_enabled == true))


#   ___  ____  _____ ____      _  _____ ___  ____    _     ___ _____ _____ ______   ______ _     _____   __  __    _    _   _    _    ____ _____ ____
#  / _ \|  _ \| ____|  _ \    / \|_   _/ _ \|  _ \  | |   |_ _|  ___| ____/ ___\ \ / / ___| |   | ____| |  \/  |  / \  | \ | |  / \  / ___| ____|  _ \
# | | | | |_) |  _| | |_) |  / _ \ | || | | | |_) | | |    | || |_  |  _|| |    \ V / |   | |   |  _|   | |\/| | / _ \ |  \| | / _ \| |  _|  _| | |_) |
# | |_| |  __/| |___|  _ <  / ___ \| || |_| |  _ <  | |___ | ||  _| | |__| |___  | || |___| |___| |___  | |  | |/ ___ \| |\  |/ ___ \ |_| | |___|  _ <
#  \___/|_|   |_____|_| \_\/_/   \_\_| \___/|_| \_\ |_____|___|_|   |_____\____| |_| \____|_____|_____| |_|  |_/_/   \_\_| \_/_/   \_\____|_____|_| \_\
#
- name: Install the Operator Lifecycle Manager if it is enabled
  block:

  - name: Check if the Operator Lifecycle Manager (olm) namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep olm | wc -l
    register: operator_lifecycle_manager_namespace_exists_output

  - block:
    - name: Generate the Operator Lifecycle Manager Custom Resource Definitions configuration
      template:
        src: operator-lifecycle-manager-crds.yaml.j2
        dest: /var/tmp/ansible/operator-lifecycle-manager-crds.yaml

    - name: Apply the Operator Lifecycle Manager Custom Resource Definitions configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/operator-lifecycle-manager-crds.yaml

    - name: Generate the Operator Lifecycle Manager configuration
      template:
        src: operator-lifecycle-manager-olm.yaml.j2
        dest: /var/tmp/ansible/operator-lifecycle-manager-olm.yaml

    - name: Apply the Operator Lifecycle Manager configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/operator-lifecycle-manager-olm.yaml

    - name: Wait for the Operator Lifecycle Manager olm-operator deployment to complete
      command:
        cmd: /usr/bin/kubectl -n olm rollout status -w deployment/olm-operator
      register: wait_for_olm_operator_deployment_result
      until: wait_for_olm_operator_deployment_result is succeeded
      retries: 180
      delay: 10

    - name: Wait for the Operator Lifecycle Manager catalog-operator deployment to complete
      command:
        cmd: /usr/bin/kubectl -n olm rollout status -w deployment/catalog-operator
      register: wait_for_catalog_operator_deployment_result
      until: wait_for_catalog_operator_deployment_result is succeeded
      retries: 180
      delay: 10

    when: operator_lifecycle_manager_namespace_exists_output.stdout == "0"

  when: ((operator_lifecycle_manager_enabled is defined) and (operator_lifecycle_manager_enabled != None) and (operator_lifecycle_manager_enabled == true))


#  ____   ___  ____ _____ ____ ____  _____ ____     ___  ____  _____ ____      _  _____ ___  ____
# |  _ \ / _ \/ ___|_   _/ ___|  _ \| ____/ ___|   / _ \|  _ \| ____|  _ \    / \|_   _/ _ \|  _ \
# | |_) | | | \___ \ | || |  _| |_) |  _| \___ \  | | | | |_) |  _| | |_) |  / _ \ | || | | | |_) |
# |  __/| |_| |___) || || |_| |  _ <| |___ ___) | | |_| |  __/| |___|  _ <  / ___ \| || |_| |  _ <
# |_|    \___/|____/ |_| \____|_| \_\_____|____/   \___/|_|   |_____|_| \_\/_/   \_\_| \___/|_| \_\
#
- name: Install the Postgres Operator if it is enabled
  block:

  - name: Check if Postgres Operator is installed
    shell:
      cmd: /usr/bin/kubectl get subscription -n operators 2>&1 | grep postgres-operator | wc -l
    register: postgres_operator_installed_output

  - block:
    - name: Generate the Postgres Operator configuration
      template:
        src: postgres-operator.yaml.j2
        dest: /var/tmp/ansible/postgres-operator.yaml

    - name: Apply the Postgres Operator configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/postgres-operator.yaml

    - name: Wait for the Postgres Operator deployment to complete
      command:
        cmd: /usr/bin/kubectl -n operators rollout status -w deployment/postgres-operator
      register: wait_for_postgres_operator_deployment_result
      until: wait_for_postgres_operator_deployment_result is succeeded
      retries: 30
      delay: 10

    when: postgres_operator_installed_output.stdout == "0"

  when: ((postgres_operator_enabled is defined) and (postgres_operator_enabled != None) and (postgres_operator_enabled == true))


#  _     ___  _   _  ____ _   _  ___  ____  _   _
# | |   / _ \| \ | |/ ___| | | |/ _ \|  _ \| \ | |
# | |  | | | |  \| | |  _| |_| | | | | |_) |  \| |
# | |__| |_| | |\  | |_| |  _  | |_| |  _ <| |\  |
# |_____\___/|_| \_|\____|_| |_|\___/|_| \_\_| \_|
#
- name: Install Longhorn if it is enabled
  block:

  - name: Check if the longhorn-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep longhorn-system | wc -l
    register: longhorn_system_namespace_exists_output

  - block:
    - template:
        src: longhorn.yaml.j2
        dest: /var/tmp/ansible/longhorn.yaml

    - name: Apply the Longhorn configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/longhorn.yaml

    - name: Wait for the Longhorn compatible-csi-attacher deployment to complete
      command:
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/compatible-csi-attacher
      register: wait_for_longhorn_compatible_csi_attacher_deployment_result
      until: wait_for_longhorn_compatible_csi_attacher_deployment_result is succeeded
      retries: 180
      delay: 10

    - name: Wait for the Longhorn csi-attacher deployment to complete
      command:
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/csi-attacher
      register: wait_for_longhorn_csi_attacher_deployment_result
      until: wait_for_longhorn_csi_attacher_deployment_result is succeeded
      retries: 180
      delay: 10

    - name: Wait for the Longhorn csi-provisioner deployment to complete
      command:
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/csi-provisioner
      register: wait_for_longhorn_csi_provisioner_deployment_result
      until: wait_for_longhorn_csi_provisioner_deployment_result is succeeded
      retries: 180
      delay: 10

    - name: Wait for the Longhorn longhorn-driver-deployer deployment to complete
      command:
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/longhorn-driver-deployer
      register: wait_for_longhorn_driver_deployer_deployment_result
      until: wait_for_longhorn_driver_deployer_deployment_result is succeeded
      retries: 180
      delay: 10

    - name: Wait for the Longhorn longhorn-ui deployment to complete
      command:
        cmd: /usr/bin/kubectl -n longhorn-system rollout status -w deployment/longhorn-ui
      register: wait_for_longhorn_ui_deployment_result
      until: wait_for_longhorn_ui_deployment_result is succeeded
      retries: 180
      delay: 10

    when: longhorn_system_namespace_exists_output.stdout == "0"

  when: ((longhorn_enabled is defined) and (longhorn_enabled != None) and (longhorn_enabled == true))


#  _____ ___  ____   ___  _ __     ____  __
# |_   _/ _ \|  _ \ / _ \| |\ \   / /  \/  |
#   | || | | | |_) | | | | | \ \ / /| |\/| |
#   | || |_| |  __/| |_| | |__\ V / | |  | |
#   |_| \___/|_|    \___/|_____\_/  |_|  |_|
#
- name: Install the TopoLVM CSI plugin
  block:

  - name: Check if the topolvm-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep topolvm-system | wc -l
    register: topolvm_system_namespace_exists_output

  - block:
    - set_fact:
        topolvm_mutatingwebhook_key: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/k8s-' + k8s_cluster_name + '-topolvm-mutatingwebhook.key') | b64encode }}"

    - set_fact:
        topolvm_mutatingwebhook_crt: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/k8s-' + k8s_cluster_name + '-topolvm-mutatingwebhook.crt') | b64encode }}"

    - set_fact:
        topolvm_mutatingwebhook_ca_bundle: "{{ lookup('file', './files/pki/' + k8s_cluster_name + '/ca-bundle.crt') | b64encode }}"

    - name: Generate the initial TopoLVM configuration
      template:
        src: topolvm-init.yaml.j2
        dest: /var/tmp/ansible/topolvm-init.yaml

    - name: Apply the initial TopoLVM configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-init.yaml

    - name: Disable the TopoLVM mutating webhook for the kube-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns kube-system topolvm.cybozu.com/webhook=ignore

    - name: Disable the TopoLVM mutating webhook for the longhorn-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns longhorn-system topolvm.cybozu.com/webhook=ignore
      when: ((longhorn_enabled is defined) and (longhorn_enabled != None) and (longhorn_enabled == true))

    - name: Disable the TopoLVM mutating webhook for the olm namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns olm topolvm.cybozu.com/webhook=ignore
      when: ((operator_lifecycle_manager_enabled is defined) and (operator_lifecycle_manager_enabled != None) and (operator_lifecycle_manager_enabled == true))

    - name: Generate the TopoLVM Custom Resource Definition configuration
      template:
        src: topolvm-crd.yaml.j2
        dest: /var/tmp/ansible/topolvm-crd.yaml

    - name: Apply the TopoLVM Custom Resource Definition configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-crd.yaml

    - name: Generate the TopoLVM Pod Security Policy configuration
      template:
        src: topolvm-psp.yaml.j2
        dest: /var/tmp/ansible/topolvm-psp.yaml

    - name: Apply the TopoLVM Pod Security Policy configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-psp.yaml

    - name: Generate the TopoLVM Scheduler daemonset configuration
      template:
        src: topolvm-scheduler-daemonset.yaml.j2
        dest: /var/tmp/ansible/topolvm-scheduler.yaml
      when: ("k8s_master" in groups.keys())

    - name: Generate the TopoLVM Scheduler service configuration
      template:
        src: topolvm-scheduler-service.yaml.j2
        dest: /var/tmp/ansible/topolvm-scheduler.yaml
      when: ("k8s_master" not in groups.keys())

    - name: Apply the TopoLVM Scheduler configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-scheduler.yaml

    - name: Generate the TopoLVM Mutating Webhooks configuration
      template:
        src: topolvm-mutatingwebhooks.yaml.j2
        dest: /var/tmp/ansible/topolvm-mutatingwebhooks.yaml

    - name: Apply the TopoLVM Mutating Webhooks configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-mutatingwebhooks.yaml

    - name: Generate the TopoLVM Controller configuration
      template:
        src: topolvm-controller.yaml.j2
        dest: /var/tmp/ansible/topolvm-controller.yaml

    - name: Apply the TopoLVM Controller configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-controller.yaml

    - name: Wait for the TopoLVM controller deployment to complete
      command:
        cmd: /usr/bin/kubectl -n topolvm-system rollout status -w deployment/controller
      register: wait_for_topo_lvm_controller_deployment_result
      until: ((wait_for_topo_lvm_controller_deployment_result is succeeded) and (wait_for_topo_lvm_controller_deployment_result.stdout == "deployment \"controller\" successfully rolled out"))
      retries: 180
      delay: 10
      when: ("k8s_worker" not in groups.keys())

    - name: Generate the TopoLVM Node configuration
      template:
        src: topolvm-node.yaml.j2
        dest: /var/tmp/ansible/topolvm-node.yaml

    - name: Apply the TopoLVM Node configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-node.yaml

    - name: Generate the TopoLVM Provisioner configuration
      template:
        src: topolvm-provisioner.yaml.j2
        dest: /var/tmp/ansible/topolvm-provisioner.yaml

    - name: Apply the TopoLVM Provisioner configuration to Kubernetes
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/topolvm-provisioner.yaml

    when: topolvm_system_namespace_exists_output.stdout == "0"

  - name: Confirm that the TopoLVM controller is available
    block:
    - name: Retrieve the IP address of the TopoLVM controller service
      shell:
        cmd: /usr/bin/kubectl -n topolvm-system get svc | tail -n +2 | awk  {'print $3'}
      register: topolvm_controller_service_ip_output

    - name: Connect to the TopoLVM controller service
      shell:
        cmd: curl --insecure https://{{ topolvm_controller_service_ip_output.stdout }}
        warn: no
      register: wait_for_topo_lvm_controller_service_result
      until: (wait_for_topo_lvm_controller_service_result is succeeded)
      retries: 180
      delay: 10

    - debug:
        msg: 'Successfully connected to TopoLVM controller service'

  when: ((topolvm_enabled is defined) and (topolvm_enabled != None) and (topolvm_enabled == true))


#  __  __  ___  _   _ ___ _____ ___  ____  ___ _   _  ____
# |  \/  |/ _ \| \ | |_ _|_   _/ _ \|  _ \|_ _| \ | |/ ___|
# | |\/| | | | |  \| || |  | || | | | |_) || ||  \| | |  _
# | |  | | |_| | |\  || |  | || |_| |  _ < | || |\  | |_| |
# |_|  |_|\___/|_| \_|___| |_| \___/|_| \_\___|_| \_|\____|
#
- name: Configure the monitoring components
  block:
  - name: Create the monitoring-system namespace
    shell:
      cmd: /usr/bin/kubectl create namespace monitoring-system --dry-run -o yaml | kubectl apply -f -

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true))


#  _____ _        _    ____ _____ ___ ____ ____  _____    _    ____   ____ _   _
# | ____| |      / \  / ___|_   _|_ _/ ___/ ___|| ____|  / \  |  _ \ / ___| | | |
# |  _| | |     / _ \ \___ \ | |  | | |   \___ \|  _|   / _ \ | |_) | |   | |_| |
# | |___| |___ / ___ \ ___) || |  | | |___ ___) | |___ / ___ \|  _ <| |___|  _  |
# |_____|_____/_/   \_\____/ |_| |___\____|____/|_____/_/   \_\_| \_\\____|_| |_|
#
- name: Install and configure Elasticsearch if it is enabled
  block:
  - name: Configure the Elasticsearch certificates and secrets if security is enabled
    block:
    - name: Create the /var/tmp/ansible/elasticsearch-pki directory
      file:
        path: /var/tmp/ansible/elasticsearch-pki
        state: directory

    - name: Copy the root CA certificate to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/ca.crt
        dest: /var/tmp/ansible/elasticsearch-pki/ca.pem

    - name: Copy the Elasticsearch private key to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-elasticsearch.key
        dest: /var/tmp/ansible/elasticsearch-pki/elasticsearch-key.pem

    - name: Copy the Elasticsearch certificate to the /var/tmp/ansible/elasticsearch-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-elasticsearch.crt
        dest: /var/tmp/ansible/elasticsearch-pki/elasticsearch-cert.pem

    - name: Create the secret in the monitoring-system namespace for the Elasticsearch private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n monitoring-system secret generic elasticsearch-certs --from-file=/var/tmp/ansible/elasticsearch-pki/elasticsearch-key.pem --from-file=/var/tmp/ansible/elasticsearch-pki/elasticsearch-cert.pem --from-file=/var/tmp/ansible/elasticsearch-pki/ca.pem --dry-run -o yaml | kubectl apply -f -

    - name: Check if the Elasticsearch credentials secret exists
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep elasticsearch-credentials | wc -l
      register: elasticsearch_credentials_secret_exists_output

    - name: Create the Elasticsearch credentials secret if it does not exist
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system create secret generic elasticsearch-credentials --from-literal=username=elastic --from-literal=password=`tr -cd '[:alnum:]' < /dev/urandom | fold -w30 | head -n1` --dry-run -o yaml | kubectl apply -f -
      when: (elasticsearch_credentials_secret_exists_output.stdout == "0")

    - name: Retrieve the Elasticsearch password
      block:
      - shell:
          cmd: /usr/bin/kubectl -n monitoring-system get secret elasticsearch-credentials -o=jsonpath='{.data.password}' | base64 --decode
        register: retrieve_elasticsearch_credentials_password_output

      - set_fact:
          elasticsearch_credentials_password: '{{ retrieve_elasticsearch_credentials_password_output.stdout }}'

      - debug:
          msg: "Elasticsearch Password: {{ elasticsearch_credentials_password }}"

    when: ((monitoring_security_enabled is defined) and (monitoring_security_enabled != None) and (monitoring_security_enabled == True))

  - name: Install a single node Elasticsearch cluster using Helm
    block:
    - name: Check if Elasticsearch is installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_installed_helm_chart_version_output

    - name: Install Elasticsearch
      block:
      - name: Generate the Elasticsearch Helm values
        template:
          src: elasticsearch-standalone-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-standalone-values.yaml

      - name: Install Elasticsearch using Helm
        command:
          cmd: /usr/bin/helm upgrade elasticsearch elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-standalone-values.yaml
      when: elasticsearch_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version
    when: (monitoring_elasticsearch_cluster_type == "standalone")

  - name: Install a multi node Elasticsearch cluster using Helm
    block:
    - name: Check if the Elasticsearch master nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-master" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_master_installed_helm_chart_version_output

    - name: Install the Elasticsearch master nodes
      block:
      - name: Generate the master nodes Elasticsearch Helm values
        template:
          src: elasticsearch-master-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-master-values.yaml

      - name: Install the Elasticsearch master nodes using Helm
        command:
          cmd: /usr/bin/helm upgrade elasticsearch-master elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-master-values.yaml
      when: elasticsearch_master_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version

    - name: Check if the Elasticsearch ingest nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-ingest" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_ingest_installed_helm_chart_version_output

    - name: Install the Elasticsearch ingest nodes
      block:
      - name: Generate the ingest nodes Elasticsearch Helm values
        template:
          src: elasticsearch-ingest-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-ingest-values.yaml

      - name: Install the Elasticsearch ingest nodes using Helm
        command:
          cmd: /usr/bin/helm upgrade elasticsearch-ingest elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-ingest-values.yaml
      when: elasticsearch_ingest_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version

    - name: Check if the Elasticsearch data nodes are installed
      shell:
        cmd: /usr/bin/helm -n monitoring-system list --filter "elasticsearch-data" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
      register: elasticsearch_data_installed_helm_chart_version_output

    - name: Install the Elasticsearch data nodes
      block:
      - name: Generate the data nodes Elasticsearch Helm values
        template:
          src: elasticsearch-data-values.yaml.j2
          dest: /var/tmp/ansible/elasticsearch-data-values.yaml

      - name: Install the Elasticsearch data nodes using Helm
        command:
          cmd: /usr/bin/helm upgrade elasticsearch-data elastic/elasticsearch --install --version={{ monitoring_elasticsearch_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/elasticsearch-data-values.yaml
      when: elasticsearch_data_installed_helm_chart_version_output.stdout != monitoring_elasticsearch_helm_chart_version

    when: ((monitoring_elasticsearch_cluster_type == "minimal") or (monitoring_elasticsearch_cluster_type == "full"))

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true))


#  _  _____ ____    _    _   _    _
# | |/ /_ _| __ )  / \  | \ | |  / \
# | ' / | ||  _ \ / _ \ |  \| | / _ \
# | . \ | || |_) / ___ \| |\  |/ ___ \
# |_|\_\___|____/_/   \_\_| \_/_/   \_\
#
- name: Install and configure Kibana if it is enabled
  block:
  - name: Configure the Kibana certificates and secrets if security is enabled
    block:
    - name: Create the /var/tmp/ansible/kibana-pki directory
      file:
        path: /var/tmp/ansible/kibana-pki
        state: directory

    - name: Copy the root CA certificate to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/ca.crt
        dest: /var/tmp/ansible/kibana-pki/ca.pem

    - name: Copy the Kibana private key to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-kibana.key
        dest: /var/tmp/ansible/kibana-pki/kibana-key.pem

    - name: Copy the Kibana certificate to the /var/tmp/ansible/kibana-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-kibana.crt
        dest: /var/tmp/ansible/kibana-pki/kibana-cert.pem

    - name: Create the secret in the monitoring-system namespace for the Kibana private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n monitoring-system secret generic kibana-certs --from-file=/var/tmp/ansible/kibana-pki/kibana-key.pem --from-file=/var/tmp/ansible/kibana-pki/kibana-cert.pem --from-file=/var/tmp/ansible/kibana-pki/ca.pem --dry-run -o yaml | kubectl apply -f -

    - name: Check if the Kibana Elasticsearch credentials secret exists
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep kibana-elasticsearch-credentials | wc -l
      register: kibana_elasticsearch_credentials_secret_exists_output

    - name: Create the Kibana Elasticsearch credentials secret if it does not exist
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system create secret generic kibana-elasticsearch-credentials --from-literal=username=elastic --from-literal=password={{ elasticsearch_credentials_password }} --dry-run -o yaml | kubectl apply -f -
      when: (kibana_elasticsearch_credentials_secret_exists_output.stdout == "0")

    when: ((monitoring_security_enabled is defined) and (monitoring_security_enabled != None) and (monitoring_security_enabled == True))

  - name: Check if Kibana is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "kibana" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: kibana_installed__helm_chart_version_output

  - name: Install Kibana
    block:
    - name: Generate the Kibana Helm values
      template:
        src: kibana-values.yaml.j2
        dest: /var/tmp/ansible/kibana-values.yaml

    - name: Install Kibana using Helm
      command:
        cmd: /usr/bin/helm upgrade kibana elastic/kibana --install --version={{ monitoring_kibana_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/kibana-values.yaml

    when: kibana_installed__helm_chart_version_output.stdout != monitoring_kibana_helm_chart_version

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true) and (monitoring_kibana_enabled is defined) and (monitoring_kibana_enabled != None) and (monitoring_kibana_enabled == true))


#      _   _    _____ ____ _____ ____
#     | | / \  | ____/ ___| ____|  _ \
#  _  | |/ _ \ |  _|| |  _|  _| | |_) |
# | |_| / ___ \| |__| |_| | |___|  _ <
#  \___/_/   \_\_____\____|_____|_| \_\
#
- name: Install and configure Jaeger if it is enabled
  block:
  - name: Configure the Jaeger certificates and secrets if security is enabled
    block:
    - name: Create the /var/tmp/ansible/jaeger-pki directory
      file:
        path: /var/tmp/ansible/jaeger-pki
        state: directory

    - name: Copy the root CA certificate to the /var/tmp/ansible/jaeger-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/ca.crt
        dest: /var/tmp/ansible/jaeger-pki/ca.pem

    - name: Copy the Jaeger private key to the /var/tmp/ansible/jaeger-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-jaeger.key
        dest: /var/tmp/ansible/jaeger-pki/jaeger-key.pem

    - name: Copy the Jaeger certificate to the /var/tmp/ansible/jaeger-pki directory
      copy:
        src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-jaeger.crt
        dest: /var/tmp/ansible/jaeger-pki/jaeger-cert.pem

    - name: Create the secret in the monitoring-system namespace for the Jaeger private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n monitoring-system secret generic jaeger-certs --from-file=/var/tmp/ansible/jaeger-pki/jaeger-key.pem --from-file=/var/tmp/ansible/jaeger-pki/jaeger-cert.pem --from-file=/var/tmp/ansible/jaeger-pki/ca.pem --dry-run -o yaml | kubectl apply -f -

    - name: Check if the Jaeger Elasticsearch credentials secret exists
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep jaeger-elasticsearch-credentials | wc -l
      register: jaeger_elasticsearch_credentials_secret_exists_output

    - name: Create the Jaeger Elasticsearch credentials secret if it does not exist
      shell:
        cmd: /usr/bin/kubectl -n monitoring-system create secret generic jaeger-elasticsearch-credentials --from-literal=username=elastic --from-literal=password={{ elasticsearch_credentials_password }} --dry-run -o yaml | kubectl apply -f -
      when: (jaeger_elasticsearch_credentials_secret_exists_output.stdout == "0")

    when: ((monitoring_security_enabled is defined) and (monitoring_security_enabled != None) and (monitoring_security_enabled == True))

  - name: Check if Jaeger is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "jaeger" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: jaeger_installed__helm_chart_version_output

  - name: Install Jaeger
    block:
    - name: Generate the Jaeger Helm values
      template:
        src: jaeger-values.yaml.j2
        dest: /var/tmp/ansible/jaeger-values.yaml

    - name: Install Jaeger using Helm
      command:
        cmd: /usr/bin/helm upgrade jaeger jaegertracing/jaeger --install --version={{ monitoring_jaeger_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/jaeger-values.yaml

    when: jaeger_installed__helm_chart_version_output.stdout != monitoring_jaeger_helm_chart_version

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_elasticsearch_enabled is defined) and (monitoring_elasticsearch_enabled != None) and (monitoring_elasticsearch_enabled == true) and (monitoring_jaeger_enabled is defined) and (monitoring_jaeger_enabled != None) and (monitoring_jaeger_enabled == true))


#  ____  ____   ___  __  __ _____ _____ _   _ _____ _   _ ____
# |  _ \|  _ \ / _ \|  \/  | ____|_   _| | | | ____| | | / ___|
# | |_) | |_) | | | | |\/| |  _|   | | | |_| |  _| | | | \___ \
# |  __/|  _ <| |_| | |  | | |___  | | |  _  | |___| |_| |___) |
# |_|   |_| \_\\___/|_|  |_|_____| |_| |_| |_|_____|\___/|____/
#
- name: Install and configure Prometheus if it is enabled
  block:
  - name: Check if Prometheus is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "prometheus" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: prometheus_installed__helm_chart_version_output

  - name: Install Prometheus
    block:
    - name: Generate the Prometheus Helm values
      template:
        src: prometheus-values.yaml.j2
        dest: /var/tmp/ansible/prometheus-values.yaml

    - name: Install Prometheus using Helm
      command:
        cmd: /usr/bin/helm upgrade prometheus stable/prometheus --install --version={{ monitoring_prometheus_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/prometheus-values.yaml

    when: prometheus_installed__helm_chart_version_output.stdout != monitoring_prometheus_helm_chart_version

  - name: Generate the Prometheus Server configuration
    template:
      src: prometheus-server-config-map.yaml.j2
      dest: /var/tmp/ansible/prometheus-server-config-map.yaml

  - name: Apply the Prometheus Server configuration to Kubernetes
    command:
      cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/prometheus-server-config-map.yaml

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_prometheus_enabled is defined) and (monitoring_prometheus_enabled != None) and (monitoring_prometheus_enabled == true))


#   ____ ____      _    _____ _    _   _    _
#  / ___|  _ \    / \  |  ___/ \  | \ | |  / \
# | |  _| |_) |  / _ \ | |_ / _ \ |  \| | / _ \
# | |_| |  _ <  / ___ \|  _/ ___ \| |\  |/ ___ \
#  \____|_| \_\/_/   \_\_|/_/   \_\_| \_/_/   \_\
#
- name: Install and configure Grafana if it is enabled
  block:
  - name: Configure the Grafana certificates and secrets
    block:
      - name: Check if the Grafana admin credentials secret exists
        shell:
          cmd: /usr/bin/kubectl -n monitoring-system get secret | awk {'print $1'} | grep grafana-admin-credentials | wc -l
        register: grafana_admin_credentials_secret_exists_output

      - name: Create the Grafana admin credentials secret if it does not exist
        shell:
          cmd: /usr/bin/kubectl -n monitoring-system create secret generic grafana-admin-credentials --from-literal=username=admin --from-literal=password=admin --dry-run -o yaml | kubectl apply -f -
        when: (grafana_admin_credentials_secret_exists_output.stdout == "0")

  - name: Check if Grafana is installed
    shell:
      cmd: /usr/bin/helm -n monitoring-system list --filter "grafana" --output json | jq -r '.[0].chart' | cut -s -f2- -d-
    register: grafana_installed_helm_chart_version_output

  - name: Install Grafana
    block:
    - name: Generate the Grafana Helm values
      template:
        src: grafana-values.yaml.j2
        dest: /var/tmp/ansible/grafana-values.yaml

    - name: Install Grafana using Helm
      command:
        cmd: /usr/bin/helm upgrade grafana stable/grafana --install --version={{ monitoring_grafana_helm_chart_version }} --namespace=monitoring-system --values=/var/tmp/ansible/grafana-values.yaml

    when: grafana_installed_helm_chart_version_output.stdout != monitoring_grafana_helm_chart_version

  - name: Generate and install the Grafana dashboard ConfigMaps
    block:
    - name: Generate the Grafana dashboard ConfigMaps
      template:
        src: grafana-dashboard-config-maps.yaml.j2
        dest: /var/tmp/ansible/grafana-dashboard-config-maps.yaml

    - name: Install the Grafana dashboard ConfigMaps
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/grafana-dashboard-config-maps.yaml

  - name: Generate and install the Grafana Istio dashboard ConfigMaps
    block:
    - name: Generate the Grafana Istio dashboard ConfigMaps
      template:
        src: istio-grafana-dashboard-config-maps.yaml.j2
        dest: /var/tmp/ansible/istio-grafana-dashboard-config-maps.yaml

    - name: Install the Grafana Istio dashboard ConfigMaps
      command:
        cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-grafana-dashboard-config-maps.yaml

    when: ((istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))

  - name: Retrieve the grafana admin username and password
    block:
    - shell:
        cmd: kubectl -n monitoring-system get secret grafana-admin-credentials -o=jsonpath='{.data.username}' | base64 --decode
      register: grafana_admin_username_output

    - debug:
        msg: "Grafana Admin Username: {{ grafana_admin_username_output.stdout }}"

    - shell:
        cmd: kubectl -n monitoring-system get secret grafana-admin-credentials -o=jsonpath='{.data.password}' | base64 --decode
      register: grafana_admin_password_output

    - debug:
        msg: "Grafana Admin Password: {{ grafana_admin_password_output.stdout }}"

  when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == true) and (monitoring_grafana_enabled is defined) and (monitoring_grafana_enabled != None) and (monitoring_grafana_enabled == true))


#  ___ ____ _____ ___ ___
# |_ _/ ___|_   _|_ _/ _ \
#  | |\___ \ | |  | | | | |
#  | | ___) || |  | | |_| |
# |___|____/ |_| |___\___/
#
- name: Install istioctl
  block:
  - debug:
      msg: Check whether the istioctl {{ istio_version }} package has been installed

  - stat:
      path: /usr/bin/istioctl
    register: istioctl_installed_stat_result

  - shell:
      cmd: /usr/bin/istioctl version --remote=false
    register: istioctl_installed_version_output
    when: (istioctl_installed_stat_result.stat.exists == True)

  - set_fact:
      istioctl_installed_version: '{{ istioctl_installed_version_output.stdout }}'
    when: (istioctl_installed_stat_result.stat.exists == True)

  - set_fact:
      istioctl_installed_version: ''
    when: (istioctl_installed_stat_result.stat.exists == False)

  - block:
    - debug:
        msg: Install the istioctl {{ istio_version }} package

    - name: Check whether the istioctl {{ istio_version }} package has been downloaded
      become: no
      local_action: stat path=packages/istioctl-{{ istio_version }}-linux.tar.gz
      register: istioctl_package_stat_result

    - name: Download the istioctl {{ istio_version }} package
      become: no
      local_action: get_url url='https://github.com/istio/istio/releases/download/{{ istio_version }}/istioctl-{{ istio_version }}-linux.tar.gz' dest='packages/istioctl-{{ istio_version }}-linux.tar.gz' checksum={{ istioctl_package_checksum }}
      when: (istioctl_package_stat_result.stat.exists == False)

    - name: Remove the existing istioctl binary
      file:
        path: /usr/bin/istioctl
        state: absent

    - name: Extract the istioctl binary from the istioctl {{ istio_version }} package
      unarchive:
        src: packages/istioctl-{{ istio_version }}-linux.tar.gz
        dest: /usr/bin
        creates: /usr/bin/istioctl

    when: (istioctl_installed_version != istio_version)

  when: ((istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))

- name: Initialize the Istio service mesh
  block:
  - name: Download and extract the Istio package if required
    block:
    - name: Check whether the istio {{ istio_version }} package has been downloaded
      become: no
      local_action: stat path=packages/istio-{{ istio_version }}-linux.tar.gz
      register: istio_package_stat_result

    - name: Download the istio {{ istio_version }} package
      become: no
      local_action: get_url url='https://github.com/istio/istio/releases/download/{{ istio_version }}/istio-{{ istio_version }}-linux.tar.gz' dest='packages/istio-{{ istio_version }}-linux.tar.gz' checksum={{ istio_package_checksum }}
      when: (istio_package_stat_result.stat.exists == False)

    - name: Extract the istio {{ istio_version }} package
      unarchive:
        src: packages/istio-{{ istio_version }}-linux.tar.gz
        dest: /var/tmp/ansible
        creates: /var/tmp/ansible/istio-{{ istio_version }}

  - name: Check if the istio-system namespace exists
    shell:
      cmd: /usr/bin/kubectl get ns | awk  {'print $1'} | grep istio-system | wc -l
    register: istio_system_namespace_exists_output

  - name: Install and configure the Istio service mesh
    block:
    - name: Copying the keys and certificates for the Istio service mesh
      block:
      - name: Create the /var/tmp/ansible/istio-pki directory
        file:
          path: /var/tmp/ansible/istio-pki
          state: directory

      - name: Copy the Istio intermediate CA private key to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca.key
          dest: /var/tmp/ansible/istio-pki/ca-key.pem

      - name: Copy the Istio intermediate CA certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca.crt
          dest: /var/tmp/ansible/istio-pki/ca-cert.pem

      - name: Copy the Root CA certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/ca.crt
          dest: /var/tmp/ansible/istio-pki/root-cert.pem

      - name: Copy the Istio intermediate CA certificate chain to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ca-chain.crt
          dest: /var/tmp/ansible/istio-pki/cert-chain.pem

      - name: Copy the Istio ingress gateway private key to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ingressgateway.key
          dest: /var/tmp/ansible/istio-pki/ingressgateway-key.pem

      - name: Copy the Istio ingress gateway certificate to the /var/tmp/ansible/istio-pki directory
        copy:
          src: pki/{{ k8s_cluster_name }}/k8s-{{ k8s_cluster_name }}-istio-ingressgateway.crt
          dest: /var/tmp/ansible/istio-pki/ingressgateway-cert.pem

    - name: Create the istio-system namespace
      shell:
        cmd: /usr/bin/kubectl create ns istio-system --dry-run -o yaml | kubectl apply -f -

    - name: Disable the TopoLVM mutating webhook for the istio-system namespace
      command:
        cmd: /usr/bin/kubectl label --overwrite ns istio-system topolvm.cybozu.com/webhook=ignore
      when: ((topolvm_enabled is defined) and (topolvm_enabled != None) and (topolvm_enabled == true))

    - name: Create the secret in the istio-system namespace for the Istio intermediate CA private key and certificates
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret generic cacerts  --from-file=/var/tmp/ansible/istio-pki/ca-cert.pem --from-file=/var/tmp/ansible/istio-pki/ca-key.pem --from-file=/var/tmp/ansible/istio-pki/root-cert.pem --from-file=/var/tmp/ansible/istio-pki/cert-chain.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Create the secret in the istio-system namespace for the Istio ingress gateway private key and certificate
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret tls istio-ingressgateway-certs --key=/var/tmp/ansible/istio-pki/ingressgateway-key.pem --cert=/var/tmp/ansible/istio-pki/ingressgateway-cert.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Create the secret in the istio-system namespace for the Istio ingress gateway CA certificate
      shell:
        cmd: /usr/bin/kubectl create -n istio-system secret generic istio-ingressgateway-ca-certs --from-file=/var/tmp/ansible/istio-pki/root-cert.pem  --dry-run -o yaml | kubectl apply -f -

    - name: Initialize the Kiali secret
      block:
      - template:
          src: istio-kiali-secret.yaml.j2
          dest: /var/tmp/ansible/istio-kiali-secret.yaml

      - name: Create the Kiali secret
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-kiali-secret.yaml

      when: ((istio_kiali_enabled is defined) and (istio_kiali_enabled != None) and (istio_kiali_enabled == true))

    - name: Create the Istio configuration file
      template:
        src: istio-config.yaml.j2
        dest: /var/tmp/ansible/istio-config.yaml

    - name: Initialize the Istio service mesh
      shell:
        cmd: /usr/bin/istioctl manifest apply -f /var/tmp/ansible/istio-config.yaml

    - name: Wait for the Istio service mesh initialization to complete
      command:
        cmd: /usr/bin/kubectl wait --namespace=istio-system --for=condition=Ready pods --all --timeout=900s
      when: ("k8s_worker" not in groups.keys())

    - name: Enable ingress for Jaeger
      block:
      - name: Generate the Jaeger ingress configuration
        template:
          src: istio-jaeger-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-jaeger-ingress.yaml

      - name: Apply the Jaeger ingress configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-jaeger-ingress.yaml

      when: (((istio_tracing_enabled is defined) and (istio_tracing_enabled != None) and (istio_tracing_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_jaeger_enabled is defined) and (monitoring_jaeger_enabled != None) and (monitoring_jaeger_enabled == True)))

    - name: Enable ingress for Kiali
      block:
      - name: Generate the Kiali ingress configuration
        template:
          src: istio-kiali-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-kiali-ingress.yaml

      - name: Apply the Kiali ingress configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-kiali-ingress.yaml

      when: ((istio_kiali_enabled is defined) and (istio_kiali_enabled != None) and (istio_kiali_enabled == true))

    - name: Enable ingress for Kibana
      block:
      - name: Generate the Kibana ingress configuration
        template:
          src: istio-kibana-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-kibana-ingress.yaml

      - name: Apply the Kibana ingress configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-kibana-ingress.yaml

      when: ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_kibana_enabled is defined) and (monitoring_kibana_enabled != None) and (monitoring_kibana_enabled == True))

    - name: Enable ingress for Grafana
      block:
      - name: Generate the Grafana ingress configuration
        template:
          src: istio-grafana-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-grafana-ingress.yaml

      - name: Apply the Grafana ingress configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-grafana-ingress.yaml

      when: (((istio_grafana_enabled is defined) and (istio_grafana_enabled != None) and (istio_grafana_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_grafana_enabled is defined) and (monitoring_grafana_enabled != None) and (monitoring_grafana_enabled == True)))

    - name: Enable ingress for Prometheus
      block:
      - name: Generate the Prometheus ingress configuration
        template:
          src: istio-prometheus-ingress.yaml.j2
          dest: /var/tmp/ansible/istio-prometheus-ingress.yaml

      - name: Apply the Prometheus ingress configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-prometheus-ingress.yaml

      when: (((istio_prometheus_enabled is defined) and (istio_prometheus_enabled != None) and (istio_prometheus_enabled == True)) or ((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_prometheus_enabled is defined) and (monitoring_prometheus_enabled != None) and (monitoring_prometheus_enabled == True)))

    - name: Enable the Prometheus service reference in the istio-system namespace
      block:
      - name: Generate the Prometheus service reference configuration
        template:
          src: istio-prometheus-service.yaml.j2
          dest: /var/tmp/ansible/istio-prometheus-service.yaml

      - name: Apply the Prometheus service reference configuration
        command:
          cmd: /usr/bin/kubectl apply -f /var/tmp/ansible/istio-prometheus-service.yaml

      when: (((monitoring_enabled is defined) and (monitoring_enabled != None) and (monitoring_enabled == True) and (monitoring_prometheus_enabled is defined) and (monitoring_prometheus_enabled != None) and (monitoring_prometheus_enabled == True)))

  when: ((istio_enabled is defined) and (istio_enabled != None) and (istio_enabled == true))



